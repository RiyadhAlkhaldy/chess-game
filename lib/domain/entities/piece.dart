//  lib/domain/entities/piece.dart
import 'package:freezed_annotation/freezed_annotation.dart';

import 'board.dart'; // For board context
import 'cell.dart'; // For cell context
import 'move.dart';

part 'piece.freezed.dart'; // Generated by freezed
part 'piece.g.dart'; // Generated by json_serializable for serialization

/// Enum representing the type of a chess piece.
enum PieceType { king, queen, rook, bishop, knight, pawn }

/// Enum representing the color of a chess piece.
enum PieceColor { white, random, black }

/// Enum representing the side for castling.
enum CastlingSide { kingSide, queenSide }

/// Abstract base class for all chess pieces.
// abstract class Piece with _$Piece {
@freezed
abstract class Piece with _$Piece {
  const Piece._(); // Private constructor for factory
  // final PieceColor color;
  // final PieceType type;
  // final bool hasMoved;
  // const Piece({required this.color, required this.type, this.hasMoved = false});
  factory Piece({
    required PieceColor color, // Color of the piece (white or black)
    required PieceType type, // Type of the piece (king, queen, etc.)
    @Default(false)
    bool
    hasMoved, // Indicates if the piece has moved from its initial position (for castling/pawn)
  }) = _Piece;

  /// Factory constructor to create a Piece from a JSON map.
  factory Piece.fromJson(Map<String, dynamic> json) => _$PieceFromJson(json);

  /// Static factory to create a specific piece instance based on its type and color.
  factory Piece.create({
    required PieceColor color,
    required PieceType type,
    bool hasMoved = true, // Default to true for hasMoved
  }) {
    switch (type) {
      case PieceType.pawn:
        return Pawn(color: color, hasMoved: hasMoved, type: type);
      case PieceType.rook:
        return Rook(color: color, hasMoved: hasMoved, type: type);
      case PieceType.knight:
        return Knight(color: color, hasMoved: hasMoved, type: type);
      case PieceType.bishop:
        return Bishop(color: color, hasMoved: hasMoved, type: type);
      case PieceType.queen:
        return Queen(color: color, hasMoved: hasMoved, type: type);
      case PieceType.king:
        return King(color: color, hasMoved: hasMoved, type: type);
    }
  }

  // /// Converts the Piece object to a JSON map.
  // @override
  // Map<String, dynamic> toJson() => {
  //   'color': color.name,
  //   'type': type.name,
  //   'hasMoved': hasMoved,
  // };
}

extension ONPiece on Piece {
  /// Creates a deep copy of the piece. Used for board simulation.
  Piece copy() => Piece(color: color, type: type);

  /// Abstract method to get all possible raw moves for the piece, without considering
  /// whether the move puts the king in check.
  List<Move> getRawMoves(Board board, Cell currentCell) {
    // debugPrint("in Piece getRawMoves type $type color $color");
    switch (type) {
      case PieceType.pawn:
        return (this as Pawn).getRawMoves(board, currentCell);
      case PieceType.rook:
        return (this as Rook).getRawMoves(board, currentCell);
      case PieceType.knight:
        return (this as Knight).getRawMoves(board, currentCell);
      case PieceType.bishop:
        return (this as Bishop).getRawMoves(board, currentCell);
      case PieceType.queen:
        return (this as Queen).getRawMoves(board, currentCell);
      case PieceType.king:
        return (this as King).getRawMoves(board, currentCell);
    }
  }
}

/// Helper function to generate linear moves (Rook, Bishop, Queen).
/// [directions] is a list of [dx, dy] pairs indicating movement vectors.
List<Move> getLinearMoves(
  Board board,
  Cell currentCell,
  PieceColor pieceColor,
  List<List<int>> directions,
) {
  final moves = <Move>[];
  for (var direction in directions) {
    int dx = direction[0];
    int dy = direction[1];
    Cell nextCell = Cell(row: currentCell.row + dx, col: currentCell.col + dy);

    while (nextCell.isValid()) {
      final targetPiece = board.getPieceAt(nextCell);
      if (targetPiece == null) {
        // Empty square, can move
        moves.add(Move(start: currentCell, end: nextCell));
      } else {
        // Square is occupied
        if (targetPiece.color != pieceColor) {
          // Can capture opponent's piece
          moves.add(Move(start: currentCell, end: nextCell, isCapture: true));
        }
        // Blocked by any piece (own or opponent's)
        break;
      }
      // Move to the next cell in the same direction
      nextCell = Cell(row: nextCell.row + dx, col: nextCell.col + dy);
    }
  }
  return moves;
}

/// Represents a King piece.
@freezed
abstract class King with _$King implements Piece {
  const King._(); // Private constructor

  const factory King({
    required PieceColor color,
    required PieceType type, // Type of the piece (king, queen, etc.)
    @Default(false) bool hasMoved,
  }) = _King;

  factory King.fromJson(Map<String, dynamic> json) => _$KingFromJson(json);

  @override
  PieceType get type => PieceType.king;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    final moves = <Move>[];
    final offsets = [
      [-1, -1],
      [-1, 0],
      [-1, 1],
      [0, -1],
      [0, 1],
      [1, -1],
      [1, 0],
      [1, 1],
    ]; // All 8 adjacent squares

    for (var offset in offsets) {
      final nextCell = Cell(
        row: currentCell.row + offset[0],
        col: currentCell.col + offset[1],
      );
      if (nextCell.isValid()) {
        final targetPiece = board.getPieceAt(nextCell);
        if (targetPiece == null || targetPiece.color != color) {
          // If the target cell is empty or occupied by an opponent's piece
          // Add the move to the list
          moves.add(
            Move(
              start: currentCell,
              end: nextCell,
              isCapture: targetPiece != null,
            ),
          );
        }
      }
    }

    // Castling: Raw moves are generated here. Legality (e.g., passing through check)
    // is checked in GameRepositoryImpl._addCastlingMoves.
    if (!hasMoved) {
      final kingRow = color == PieceColor.white ? 7 : 0;
      // King-side castling
      // Check if the king-side rook has not moved and the squares between the king and rook are empty
      if (board.castlingRights[color]![CastlingSide.kingSide]! &&
          board.getPieceAt(Cell(row: kingRow, col: 5)) == null &&
          board.getPieceAt(Cell(row: kingRow, col: 6)) == null) {
        // if (board.isCellUnderAttack(color, Cell(row: kingRow, col: 5)) ==
        //         false &&
        //     board.isCellUnderAttack(color, Cell(row: kingRow, col: 6)) ==
        //         false) {
        moves.add(
          Move(
            start: currentCell,
            end: Cell(row: kingRow, col: 6),
            isCastling: true,
          ),
        );
        // }
      }
      // Queen-side castling
      // Check if the queen-side rook has not moved and the squares between the king and rook are empty
      if (board.castlingRights[color]![CastlingSide.queenSide]! &&
          board.getPieceAt(Cell(row: kingRow, col: 3)) == null &&
          board.getPieceAt(Cell(row: kingRow, col: 2)) == null &&
          board.getPieceAt(Cell(row: kingRow, col: 1)) == null) {
        // if (board.isCellUnderAttack(color, Cell(row: kingRow, col: 3)) ==
        //         false &&
        //     board.isCellUnderAttack(color, Cell(row: kingRow, col: 2)) ==
        //         false) {
        moves.add(
          Move(
            start: currentCell,
            end: Cell(row: kingRow, col: 2),
            isCastling: true,
          ),
        );
        // }
      }
    }
    return moves;
  }

  King copy() => King(color: color, hasMoved: hasMoved, type: type);
}

/// queen
@freezed
abstract class Queen with _$Queen implements Piece {
  const Queen._(); // Private constructor

  const factory Queen({
    required PieceColor color,
    required PieceType type, // Type of the piece (king, queen, etc.)
    @Default(false) bool hasMoved,
  }) = _Queen;

  factory Queen.fromJson(Map<String, dynamic> json) => _$QueenFromJson(json);

  @override
  PieceType get type => PieceType.queen;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    // Queen moves like a Rook + Bishop
    final directions = [
      [-1, 0], [1, 0], [0, -1], [0, 1], // Horizontal & Vertical
      [-1, -1], [-1, 1], [1, -1], [1, 1], // Diagonal
    ];
    return getLinearMoves(board, currentCell, color, directions);
  }

  Queen copy() => Queen(color: color, hasMoved: hasMoved, type: type);
}

// rook

/// Represents a Rook piece.
@freezed
abstract class Rook with _$Rook implements Piece {
  const Rook._(); // Private constructor

  const factory Rook({
    required PieceColor color,
    required PieceType type,
    @Default(false) bool hasMoved,
  }) = _Rook;

  factory Rook.fromJson(Map<String, dynamic> json) => _$RookFromJson(json);

  @override
  PieceType get type => PieceType.rook;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    final directions = [
      [-1, 0], // Up
      [1, 0], // Down
      [0, -1], // Left
      [0, 1], // Right
    ];
    return getLinearMoves(board, currentCell, color, directions);
  }

  Rook copy() => Rook(color: color, hasMoved: hasMoved, type: type);
}

/// Represents a Bishop piece.
@freezed
abstract class Bishop with _$Bishop implements Piece {
  const Bishop._(); // Private constructor

  const factory Bishop({
    required PieceColor color,
    required PieceType type,
    @Default(false) bool hasMoved,
  }) = _Bishop;

  factory Bishop.fromJson(Map<String, dynamic> json) => _$BishopFromJson(json);

  @override
  PieceType get type => PieceType.bishop;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    final directions = [
      [-1, -1],
      [-1, 1],
      [1, -1],
      [1, 1],
    ]; // All 4 diagonal directions
    return getLinearMoves(board, currentCell, color, directions);
  }

  Bishop copy() => Bishop(color: color, hasMoved: hasMoved, type: type);
}

/// Represents a Knight piece.
@freezed
abstract class Knight with _$Knight implements Piece {
  const Knight._(); // Private constructor

  const factory Knight({
    required PieceColor color,
    required PieceType type,
    @Default(false) bool hasMoved,
  }) = _Knight;

  factory Knight.fromJson(Map<String, dynamic> json) => _$KnightFromJson(json);

  @override
  PieceType get type => PieceType.knight;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    final moves = <Move>[];
    final offsets = [
      [1, 2],
      [1, -2],
      [-1, 2],
      [-1, -2],
      [2, 1],
      [2, -1],
      [-2, 1],
      [-2, -1],
    ]; // All 8 L-shaped moves

    for (var offset in offsets) {
      final nextCell = Cell(
        row: currentCell.row + offset[0],
        col: currentCell.col + offset[1],
      );
      if (nextCell.isValid()) {
        final targetPiece = board.getPieceAt(nextCell);
        if (targetPiece == null || targetPiece.color != color) {
          moves.add(
            Move(
              start: currentCell,
              end: nextCell,
              isCapture: targetPiece != null,
            ),
          );
        }
      }
    }
    return moves;
  }

  Knight copy() => Knight(color: color, hasMoved: hasMoved, type: type);
}

/// Represents a Pawn piece.
//
//
@freezed
abstract class Pawn with _$Pawn implements Piece {
  const Pawn._(); // Private constructor

  const factory Pawn({
    required PieceColor color,
    required PieceType type,
    @Default(false) bool hasMoved,
  }) = _Pawn;

  factory Pawn.fromJson(Map<String, dynamic> json) => _$PawnFromJson(json);

  @override
  PieceType get type => PieceType.pawn;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    final moves = <Move>[];
    final direction =
        color == PieceColor.white
            ? -1
            : 1; // -1 for white (up), 1 for black (down)

    // 1. Move forward one square
    final oneStepCell = Cell(
      row: currentCell.row + direction,
      col: currentCell.col,
    );
    if (oneStepCell.isValid() && board.getPieceAt(oneStepCell) == null) {
      // check if promotion is possible
      if (color == PieceColor.white && oneStepCell.row == 0) {
        // White pawn promotion
        moves.add(
          Move(start: currentCell, end: oneStepCell, isPromotion: true),
        );
      } else if (color == PieceColor.black && oneStepCell.row == 7) {
        // Black pawn promotion
        moves.add(
          Move(start: currentCell, end: oneStepCell, isPromotion: true),
        );
      } else {
        // Normal pawn move
        moves.add(Move(start: currentCell, end: oneStepCell));
      }
    }

    // 2. Move forward two squares (initial move)
    final twoStepCell = Cell(
      row: currentCell.row + 2 * direction,
      col: currentCell.col,
    );
    if (!hasMoved &&
        oneStepCell.isValid() &&
        board.getPieceAt(oneStepCell) == null &&
        twoStepCell.isValid() &&
        board.getPieceAt(twoStepCell) == null) {
      moves.add(
        Move(start: currentCell, end: twoStepCell, isTwoStepPawnMove: true),
      );
    }

    // 3. Captures (diagonal)
    final captureLeftCell = Cell(
      row: currentCell.row + direction,
      col: currentCell.col - 1,
    );
    final captureRightCell = Cell(
      row: currentCell.row + direction,
      col: currentCell.col + 1,
    );

    // Check left diagonal capture
    if (captureLeftCell.isValid()) {
      final targetPiece = board.getPieceAt(captureLeftCell);
      if (targetPiece != null && targetPiece.color != color) {
        moves.add(
          Move(start: currentCell, end: captureLeftCell, isCapture: true),
        );
      }
    }

    // Check right diagonal capture
    if (captureRightCell.isValid()) {
      final targetPiece = board.getPieceAt(captureRightCell);
      if (targetPiece != null && targetPiece.color != color) {
        moves.add(
          Move(start: currentCell, end: captureRightCell, isCapture: true),
        );
      }
    }

    // 4. En Passant (requires checking the board's state from the previous move)
    // This will be fully validated in GameRepositoryImpl
    if (board.enPassantTarget != null &&
        (board.enPassantTarget == captureLeftCell ||
            board.enPassantTarget == captureRightCell)) {
      moves.add(
        Move(
          start: currentCell,
          end: board.enPassantTarget!,
          isEnPassant: true,
        ),
      );
    }

    // 5. Promotion (not handled here, should be done in GameRepositoryImpl)
    // Promotion logic is typically handled in the game logic, not in the piece itself.
    // For example, if a pawn reaches the last row, it can be promoted to a queen, rook, bishop, or knight.

    return moves;
  }

  Pawn copy() => Pawn(color: color, hasMoved: hasMoved, type: type);
}
