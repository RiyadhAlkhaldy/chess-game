// lib/domain/entities/board.dart
import 'package:freezed_annotation/freezed_annotation.dart';

import 'cell.dart';
import 'move.dart';
import 'piece.dart';

part 'board.freezed.dart'; // Generated by freezed
part 'board.g.dart';

// const _Board({required final  List<List<Piece?>> squares, final  List<Move> moveHistory = const [], this.currentPlayer = PieceColor.white, required final  Map<PieceColor, Cell> kingPositions, final  Map<PieceColor, Map<CastlingSide, bool>> castlingRights = const { PieceColor.white: { CastlingSide.kingSide : true, CastlingSide.queenSide : true},  PieceColor.black : {CastlingSide.kingSide: true, CastlingSide.queenSide: true}}, this.enPassantTarget, this.halfMoveClock = 0, this.fullMoveNumber = 1}): _squares = squares,_moveHistory = moveHistory,_kingPositions = kingPositions,_castlingRights = castlingRights;

/// Represents the current state of the chessboard.
@freezed
abstract class Board with _$Board {
  const factory Board({
    required List<List<Piece?>>
    squares, // 8x8 grid representing the board cells
    @Default([]) List<Move> moveHistory, // History of moves made in the game
    @Default(PieceColor.white)
    PieceColor currentPlayer, // Current player to move
    required Map<PieceColor, Cell>
    kingPositions, // Tracks the current position of each king
    @Default({
      PieceColor.white: {
        CastlingSide.kingSide: true,
        CastlingSide.queenSide: true,
      },
      PieceColor.black: {
        CastlingSide.kingSide: true,
        CastlingSide.queenSide: true,
      },
    })
    Map<PieceColor, Map<CastlingSide, bool>>
    castlingRights, // Tracks castling rights for each player
    // Map<PieceColor, Map<CastlingSide, bool>>
    // castlingLefts, // Tracks castling rights for each player
    Cell? enPassantTarget, // The cell where an en passant capture is possible
    @Default(0)
    int
    halfMoveClock, // Number of half-moves since the last capture or pawn advance (for fifty-move rule)
    @Default(1)
    int fullMoveNumber, // Number of full moves (increments after Black's move)
    // إضافة لسجل وضعيات اللوحة للتحقق من التكرار الثلاثي
    // A list of FEN strings or a similar unique board state representation
    @Default([]) List<String> positionHistory,
  }) = _Board;

  /// Factory constructor to set up the initial state of a chess board.
  factory Board.initial() {
    final List<List<Piece?>> initialSquares = List.generate(
      8,
      (_) => List.filled(8, null),
    );

    // Place pawns
    for (int col = 0; col < 8; col++) {
      initialSquares[1][col] = Pawn(
        color: PieceColor.black,
        type: PieceType.pawn,
      );
      initialSquares[6][col] = Pawn(
        color: PieceColor.white,
        type: PieceType.pawn,
      );
    }

    // Place other pieces for Black
    initialSquares[0][0] = Rook(color: PieceColor.black, type: PieceType.rook);
    initialSquares[0][1] = Knight(
      color: PieceColor.black,
      type: PieceType.knight,
    );
    initialSquares[0][2] = Bishop(
      color: PieceColor.black,
      type: PieceType.bishop,
    );
    initialSquares[0][3] = Queen(
      color: PieceColor.black,
      type: PieceType.queen,
    );
    initialSquares[0][4] = King(color: PieceColor.black, type: PieceType.king);
    initialSquares[0][5] = Bishop(
      color: PieceColor.black,
      type: PieceType.bishop,
    );
    initialSquares[0][6] = Knight(
      color: PieceColor.black,
      type: PieceType.knight,
    );
    initialSquares[0][7] = Rook(color: PieceColor.black, type: PieceType.rook);

    // Place other pieces for White
    initialSquares[7][0] = Rook(color: PieceColor.white, type: PieceType.rook);
    initialSquares[7][1] = Knight(
      color: PieceColor.white,
      type: PieceType.knight,
    );
    initialSquares[7][2] = Bishop(
      color: PieceColor.white,
      type: PieceType.bishop,
    );
    initialSquares[7][3] = Queen(
      color: PieceColor.white,
      type: PieceType.queen,
    );
    initialSquares[7][4] = King(color: PieceColor.white, type: PieceType.king);
    initialSquares[7][5] = Bishop(
      color: PieceColor.white,
      type: PieceType.bishop,
    );
    initialSquares[7][6] = Knight(
      color: PieceColor.white,
      type: PieceType.knight,
    );
    initialSquares[7][7] = Rook(color: PieceColor.white, type: PieceType.rook);

    // Initial king positions
    final Map<PieceColor, Cell> initialKingPositions = {
      PieceColor.white: const Cell(row: 7, col: 4),
      PieceColor.black: const Cell(row: 0, col: 4),
    };
    // Initial FEN for the starting position - FEN الأولي للوضعية الافتتاحية
    final initialFen = _boardToFen(
      initialSquares,
      PieceColor.white,
      initialKingPositions,
      const {},
      null,
      0,
      1,
    );
    return Board(
      squares: initialSquares,
      kingPositions: initialKingPositions,
      currentPlayer: PieceColor.white,
      positionHistory: [initialFen], // Add initial position to history
    );
  }

  factory Board.fromJson(Map<String, dynamic> json) => _$BoardFromJson(json);
}

extension OnBoard on Board {
  /// Creates a deep copy of the board, including all pieces, for simulation purposes.
  /// يُنشئ نسخة عميقة من اللوحة، بما في ذلك جميع القطع، لأغراض المحاكاة.
  Board copyWithDeepPieces() {
    final newSquares =
        squares
            .map(
              (row) =>
                  row
                      .map((piece) => piece == null ? piece : piece.copyWith())
                      .toList(),
            )
            .toList(); // نسخ القطع هنا

    // نسخ الخرائط المتغيرة بشكل عميق لضمان عدم وجود مراجع مشتركة
    final newMoveHistory = List<Move>.from(moveHistory);
    final newKingPositions = Map<PieceColor, Cell>.from(kingPositions);
    final newCastlingRights = castlingRights.map(
      (key, value) => MapEntry(key, Map<CastlingSide, bool>.from(value)),
    );
    final newPositionHistory = List<String>.from([
      toFenString(),
    ]); // نسخ سجل الوضعيات

    return copyWith(
      squares: newSquares,
      moveHistory: newMoveHistory, // استخدم النسخة العميقة
      kingPositions: newKingPositions, // استخدم النسخة العميقة
      castlingRights: newCastlingRights, // استخدم النسخة العميقة
      currentPlayer: currentPlayer,
      enPassantTarget: enPassantTarget,
      fullMoveNumber: fullMoveNumber,
      halfMoveClock: halfMoveClock,
      positionHistory: newPositionHistory, // استخدم النسخة العميقة
    );
  }

  /// Retrieves the piece at a given cell on the board.
  Piece? getPieceAt(Cell cell) {
    if (cell.isValid()) {
      return squares[cell.row][cell.col];
    }
    return null;
  }

  /// يُرجع مثيل Board جديدًا مع وضع قطعة (أو إزالتها إذا كانت القطعة null)
  /// في الخلية المحددة. هذا تحديث غير قابل للتغيير.
  Board placePiece(Cell cell, Piece? piece) {
    final newSquares = squares.map((row) => List<Piece?>.from(row)).toList();
    newSquares[cell.row][cell.col] = piece;
    return copyWith(squares: newSquares);
  }

  /// يتحقق مما إذا كان الملك للّون المحدد في حالة كش (Check).
  bool isKingInCheck(PieceColor kingColor) {
    final kingPosition = kingPositions[kingColor];
    if (kingPosition == null) return false; // لا ينبغي أن يحدث في لعبة عادية

    // تحقق مما إذا كانت أي قطعة للخصم تهدد مربع الملك
    final opponentColor =
        kingColor == PieceColor.white ? PieceColor.black : PieceColor.white;
    for (int r = 0; r < 8; r++) {
      for (int c = 0; c < 8; c++) {
        final currentCell = Cell(row: r, col: c);
        final piece = getPieceAt(currentCell);
        if (piece != null && piece.color == opponentColor) {
          // نحتاج إلى الحصول على الحركات الأولية للقطعة المهاجمة
          // لا نستخدم getLegalMoves هنا لأننا نريد جميع الهجمات، حتى لو كانت تضع ملك المهاجم في كش
          // (مثل دبوس على قطعة الخصم)
          final attackingMoves = piece.getRawMoves(this, currentCell);
          for (var move in attackingMoves) {
            if (move.end == kingPosition) {
              return true; // الملك في كش
            }
          }
        }
      }
    }
    return false;
  }

  /// يتحقق مما إذا كانت الخلية المحددة مهددة من قبل قطع الخصم.
  /// تُستخدم للتحقق من شرعية التبييت.
  bool isCellUnderAttack(PieceColor playerColor, Cell cell) {
    final opponentColor =
        playerColor == PieceColor.white ? PieceColor.black : PieceColor.white;

    for (int r = 0; r < 8; r++) {
      for (int c = 0; c < 8; c++) {
        final currentCell = Cell(row: r, col: c);
        final piece = getPieceAt(currentCell);
        if (piece != null && piece.color == opponentColor) {
          // الحصول على جميع الحركات الأولية للقطعة (التهديدات)
          final attackingMoves = piece.getRawMoves(this, currentCell);
          for (var move in attackingMoves) {
            if (move.end == cell) {
              return true; // الخلية مهددة
            }
          }
        }
      }
    }
    return false;
  }

  /// يقوم بتحويل حالة اللوحة الحالية إلى تمثيل FEN جزئي
  /// (فقط الجزء الضروري لتحديد التكرار الثلاثي).
  String toFenString() {
    String fen = '';
    for (int r = 0; r < 8; r++) {
      int emptyCount = 0;
      for (int c = 0; c < 8; c++) {
        final piece = squares[r][c];
        if (piece == null) {
          emptyCount++;
        } else {
          if (emptyCount > 0) {
            fen += emptyCount.toString();
            emptyCount = 0;
          }
          String pieceChar;
          switch (piece.type) {
            case PieceType.pawn:
              pieceChar = 'p';
              break;
            case PieceType.rook:
              pieceChar = 'r';
              break;
            case PieceType.knight:
              pieceChar = 'n';
              break;
            case PieceType.bishop:
              pieceChar = 'b';
              break;
            case PieceType.queen:
              pieceChar = 'q';
              break;
            case PieceType.king:
              pieceChar = 'k';
              break;
          }
          fen +=
              piece.color == PieceColor.white
                  ? pieceChar.toUpperCase()
                  : pieceChar;
        }
      }
      if (emptyCount > 0) {
        fen += emptyCount.toString();
      }
      if (r < 7) {
        fen += '/';
      }
    }

    // Current player - اللاعب الحالي
    fen += ' ${currentPlayer == PieceColor.white ? 'w' : 'b'}';

    // Castling rights - حقوق التبييت
    String castlingFen = '';
    if (castlingRights[PieceColor.white]![CastlingSide.kingSide]!) {
      castlingFen += 'K';
    }
    if (castlingRights[PieceColor.white]![CastlingSide.queenSide]!) {
      castlingFen += 'Q';
    }
    if (castlingRights[PieceColor.black]![CastlingSide.kingSide]!) {
      castlingFen += 'k';
    }
    if (castlingRights[PieceColor.black]![CastlingSide.queenSide]!) {
      castlingFen += 'q';
    }
    fen += ' ${castlingFen.isEmpty ? '-' : castlingFen}';

    // En passant target square - مربع الأخذ بالمرور المستهدف
    fen +=
        ' ${enPassantTarget == null ? '-' : String.fromCharCode(97 + enPassantTarget!.col) + (8 - enPassantTarget!.row).toString()}';

    // Halfmove clock - عداد أنصاف الحركات
    fen += ' $halfMoveClock';

    // Fullmove number - رقم الحركة الكاملة
    fen += ' $fullMoveNumber';

    return fen;
  }
}

// دالة مساعدة لتحويل اللوحة إلى FEN (لاستخدامها في Board.initial)
String _boardToFen(
  List<List<Piece?>> squares,
  PieceColor currentPlayer,
  Map<PieceColor, Cell> kingPositions,
  Map<PieceColor, Map<CastlingSide, bool>> castlingRights,
  Cell? enPassantTarget,
  int halfMoveClock,
  int fullMoveNumber,
) {
  String fen = '';
  for (int r = 0; r < 8; r++) {
    int emptyCount = 0;
    for (int c = 0; c < 8; c++) {
      final piece = squares[r][c];
      if (piece == null) {
        emptyCount++;
      } else {
        if (emptyCount > 0) {
          fen += emptyCount.toString();
          emptyCount = 0;
        }
        String pieceChar;
        switch (piece.type) {
          case PieceType.pawn:
            pieceChar = 'p';
            break;
          case PieceType.rook:
            pieceChar = 'r';
            break;
          case PieceType.knight:
            pieceChar = 'n';
            break;
          case PieceType.bishop:
            pieceChar = 'b';
            break;
          case PieceType.queen:
            pieceChar = 'q';
            break;
          case PieceType.king:
            pieceChar = 'k';
            break;
        }
        fen +=
            piece.color == PieceColor.white
                ? pieceChar.toUpperCase()
                : pieceChar;
      }
    }
    if (emptyCount > 0) {
      fen += emptyCount.toString();
    }
    if (r < 7) {
      fen += '/';
    }
  }

  fen += ' ${currentPlayer == PieceColor.white ? 'w' : 'b'}';

  String castlingFen = '';
  // Since castlingRights is default for initial board, it will be empty map {}
  // when passed to this helper unless explicitly defined. We need to handle this.
  // For initial board, hardcode the full castling rights
  castlingFen += 'KQkq'; // Assuming all castling rights are initially true
  fen += ' ${castlingFen.isEmpty ? '-' : castlingFen}';

  fen +=
      ' ${enPassantTarget == null ? '-' : String.fromCharCode(97 + enPassantTarget.col) + (8 - enPassantTarget.row).toString()}';
  fen += ' $halfMoveClock';
  fen += ' $fullMoveNumber';

  return fen;
}
