import 'package:freezed_annotation/freezed_annotation.dart';

import '../repositories/simulate_move.dart';
import '../repositories/zobrist_hasher.dart';
import 'cell.dart';
import 'move.dart';
import 'piece.dart';

part 'board.freezed.dart'; // Generated by freezed
part 'board.g.dart';

/// Represents the current state of the chessboard.
@freezed
abstract class Board with _$Board {
  const factory Board({
    required List<List<Piece?>>
    squares, // 8x8 grid representing the board cells
    @Default([]) List<Move> moveHistory, // History of moves made in the game
    @Default([]) List<Move> redoStack, // History of moves that can be redone
    @Default(PieceColor.white)
    PieceColor currentPlayer, // Current player to move
    required Map<PieceColor, Cell>
    kingPositions, // Tracks the current position of each king
    @Default({
      PieceColor.white: {
        CastlingSide.kingSide: true,
        CastlingSide.queenSide: true,
      },
      PieceColor.black: {
        CastlingSide.kingSide: true,
        CastlingSide.queenSide: true,
      },
    })
    Map<PieceColor, Map<CastlingSide, bool>>
    castlingRights, // Tracks castling rights for each player
    // Map<PieceColor, Map<CastlingSide, bool>>
    // castlingLefts, // Tracks castling rights for each player
    Cell? enPassantTarget, // The cell where an en passant capture is possible
    @Default(0)
    int
    halfMoveClock, // Number of half-moves since the last capture or pawn advance (for fifty-move rule)
    @Default(1)
    int fullMoveNumber, // Number of full moves (increments after Black's move)
    // إضافة لسجل وضعيات اللوحة للتحقق من التكرار الثلاثي
    // A list of FEN strings or a similar unique board state representation
    @Default([]) List<String> positionHistory,
    @Default(0) int zobristKey,
  }) = _Board;

  /// Factory constructor to set up the initial state of a chess board.
  factory Board.initial() {
    final List<List<Piece?>> initialSquares = List.generate(
      8,
      (_) => List.filled(8, null),
    );

    // Place pawns
    for (int col = 0; col < 8; col++) {
      initialSquares[1][col] = Pawn(
        color: PieceColor.black,
        type: PieceType.pawn,
      );
      initialSquares[6][col] = Pawn(
        color: PieceColor.white,
        type: PieceType.pawn,
      );
    }

    // Place other pieces for Black
    initialSquares[0][0] = Rook(color: PieceColor.black, type: PieceType.rook);
    initialSquares[0][1] = Knight(
      color: PieceColor.black,
      type: PieceType.knight,
    );
    initialSquares[0][2] = Bishop(
      color: PieceColor.black,
      type: PieceType.bishop,
    );
    initialSquares[0][3] = Queen(
      color: PieceColor.black,
      type: PieceType.queen,
    );
    initialSquares[0][4] = King(color: PieceColor.black, type: PieceType.king);
    initialSquares[0][5] = Bishop(
      color: PieceColor.black,
      type: PieceType.bishop,
    );
    initialSquares[0][6] = Knight(
      color: PieceColor.black,
      type: PieceType.knight,
    );
    initialSquares[0][7] = Rook(color: PieceColor.black, type: PieceType.rook);

    // Place other pieces for White
    initialSquares[7][0] = Rook(color: PieceColor.white, type: PieceType.rook);
    initialSquares[7][1] = Knight(
      color: PieceColor.white,
      type: PieceType.knight,
    );
    initialSquares[7][2] = Bishop(
      color: PieceColor.white,
      type: PieceType.bishop,
    );
    initialSquares[7][3] = Queen(
      color: PieceColor.white,
      type: PieceType.queen,
    );
    initialSquares[7][4] = King(color: PieceColor.white, type: PieceType.king);
    initialSquares[7][5] = Bishop(
      color: PieceColor.white,
      type: PieceType.bishop,
    );
    initialSquares[7][6] = Knight(
      color: PieceColor.white,
      type: PieceType.knight,
    );
    initialSquares[7][7] = Rook(color: PieceColor.white, type: PieceType.rook);

    // Initial king positions
    final Map<PieceColor, Cell> initialKingPositions = {
      PieceColor.white: const Cell(row: 7, col: 4),
      PieceColor.black: const Cell(row: 0, col: 4),
    };
    // Initial FEN for the starting position - FEN الأولي للوضعية الافتتاحية
    final initialFen = _boardToFen(
      initialSquares,
      PieceColor.white,
      initialKingPositions,
      const {},
      null,
      0,
      1,
    );
    return Board(
      squares: initialSquares,
      kingPositions: initialKingPositions,
      currentPlayer: PieceColor.white,
      positionHistory: [initialFen], // Add initial position to history
    );
  }

  /// Builds a Board object from a FEN (Forsyth-Edwards Notation) string.
  /// يبني كائن Board من سلسلة FEN (تدوين فورسيث-إدواردز).
  factory Board.fenToBoard(String fen) {
    final parts = fen.split(' ');
    if (parts.length != 6) {
      throw ArgumentError('Invalid FEN string: "$fen". Must have 6 parts.');
    }

    // 1. Piece placement data (board state)
    // 1. بيانات وضع القطع (حالة اللوحة)
    final piecePlacement = parts[0];
    final List<List<Piece?>> squares = List.generate(
      8,
      (_) => List.filled(8, null),
    );
    final Map<PieceColor, Cell> kingPositions = {};

    int row = 0;
    int col = 0;
    for (int i = 0; i < piecePlacement.length; i++) {
      final char = piecePlacement[i];
      if (char == '/') {
        row++;
        col = 0;
      } else if (int.tryParse(char) != null) {
        col += int.parse(char);
      } else {
        final PieceColor color =
            char.toUpperCase() == char ? PieceColor.white : PieceColor.black;
        PieceType type;
        switch (char.toLowerCase()) {
          case 'p':
            type = PieceType.pawn;
            break;
          case 'r':
            type = PieceType.rook;
            break;
          case 'n':
            type = PieceType.knight;
            break;
          case 'b':
            type = PieceType.bishop;
            break;
          case 'q':
            type = PieceType.queen;
            break;
          case 'k':
            type = PieceType.king;
            // Track king positions
            // تتبع مواقع الملوك
            kingPositions[color] = Cell(row: row, col: col);
            break;
          default:
            throw ArgumentError('Invalid piece character in FEN: $char');
        }
        // Determine if the piece has moved. For FEN, we assume all pieces
        // have "moved" unless they are in their initial pawn/rook/king positions
        // that allow special moves like castling or two-step pawn moves.
        // Since FEN only gives the current state, `hasMoved` is tricky.
        // For castling, we rely on the castling rights string.
        // For pawns, if they are not on their starting rank, they have "moved".
        // تحديد ما إذا كانت القطعة قد تحركت. بالنسبة لـ FEN، نفترض أن جميع القطع
        // "تحركت" ما لم تكن في مواقعها الأولية للبيدق/الرخ/الملك
        // التي تسمح بحركات خاصة مثل التبييت أو حركات البيدق المزدوجة.
        // بما أن FEN يعطي الحالة الحالية فقط، فإن `hasMoved` أمر معقد.
        // بالنسبة للتبييت، نعتمد على سلسلة حقوق التبييت.
        // بالنسبة للبيادق، إذا لم تكن في صف البداية، فقد "تحركت".
        bool hasMoved = true;
        if (type == PieceType.pawn) {
          if ((color == PieceColor.white && row == 6) ||
              (color == PieceColor.black && row == 1)) {
            hasMoved =
                false; // Pawns on starting rank are considered not moved for 2-step
            // البيادق في صف البداية تعتبر غير متحركة لحركة الخطوتين
          }
        } else if (type == PieceType.king) {
          if ((color == PieceColor.white && row == 7 && col == 4) ||
              (color == PieceColor.black && row == 0 && col == 4)) {
            // Has moved status for King will be overwritten by castling rights.
            // ستتم الكتابة فوق حالة "تحرك" للملك بواسطة حقوق التبييت.
            hasMoved = false;
          }
        } else if (type == PieceType.rook) {
          // Has moved status for Rook will be overwritten by castling rights.
          // ستتم الكتابة فوق حالة "تحرك" للرخ بواسطة حقوق التبييت.
          if ((color == PieceColor.white &&
                  ((row == 7 && col == 0) || (row == 7 && col == 7))) ||
              (color == PieceColor.black &&
                  ((row == 0 && col == 0) || (row == 0 && col == 7)))) {
            hasMoved = false;
          }
        }

        squares[row][col] = Piece.create(
          color: color,
          type: type,
          hasMoved: hasMoved,
        );
        col++;
      }
    }

    // 2. Active color
    // 2. اللون النشط
    final currentPlayer = parts[1] == 'w' ? PieceColor.white : PieceColor.black;

    // 3. Castling availability
    // 3. توفر التبييت
    final castlingFen = parts[2];
    final Map<PieceColor, Map<CastlingSide, bool>> castlingRights = {
      PieceColor.white: {
        CastlingSide.kingSide: false,
        CastlingSide.queenSide: false,
      },
      PieceColor.black: {
        CastlingSide.kingSide: false,
        CastlingSide.queenSide: false,
      },
    };
    if (castlingFen != '-') {
      if (castlingFen.contains('K')) {
        castlingRights[PieceColor.white]![CastlingSide.kingSide] = true;
      }
      if (castlingFen.contains('Q')) {
        castlingRights[PieceColor.white]![CastlingSide.queenSide] = true;
      }
      if (castlingFen.contains('k')) {
        castlingRights[PieceColor.black]![CastlingSide.kingSide] = true;
      }
      if (castlingFen.contains('q')) {
        castlingRights[PieceColor.black]![CastlingSide.queenSide] = true;
      }
    }

    // Set hasMoved for kings and rooks based on castling rights
    // If castling right exists for a side, the king and corresponding rook for that side must not have moved.
    // اضبط hasMoved للملوك والرخاخ بناءً على حقوق التبييت
    // إذا كان حق التبييت موجودًا لجانب ما، يجب ألا يكون الملك والرخ المقابل لهذا الجانب قد تحركا.
    if (castlingRights[PieceColor.white]![CastlingSide.kingSide] == true) {
      if (squares[7][4] is King && squares[7][4]!.color == PieceColor.white) {
        squares[7][4] = (squares[7][4] as King).copyWith(hasMoved: false);
      }
      if (squares[7][7] is Rook && squares[7][7]!.color == PieceColor.white) {
        squares[7][7] = (squares[7][7] as Rook).copyWith(hasMoved: false);
      }
    }
    if (castlingRights[PieceColor.white]![CastlingSide.queenSide] == true) {
      if (squares[7][4] is King && squares[7][4]!.color == PieceColor.white) {
        squares[7][4] = (squares[7][4] as King).copyWith(hasMoved: false);
      }
      if (squares[7][0] is Rook && squares[7][0]!.color == PieceColor.white) {
        squares[7][0] = (squares[7][0] as Rook).copyWith(hasMoved: false);
      }
    }
    if (castlingRights[PieceColor.black]![CastlingSide.kingSide] == true) {
      if (squares[0][4] is King && squares[0][4]!.color == PieceColor.black) {
        squares[0][4] = (squares[0][4] as King).copyWith(hasMoved: false);
      }
      if (squares[0][7] is Rook && squares[0][7]!.color == PieceColor.black) {
        squares[0][7] = (squares[0][7] as Rook).copyWith(hasMoved: false);
      }
    }
    if (castlingRights[PieceColor.black]![CastlingSide.queenSide] == true) {
      if (squares[0][4] is King && squares[0][4]!.color == PieceColor.black) {
        squares[0][4] = (squares[0][4] as King).copyWith(hasMoved: false);
      }
      if (squares[0][0] is Rook && squares[0][0]!.color == PieceColor.black) {
        squares[0][0] = (squares[0][0] as Rook).copyWith(hasMoved: false);
      }
    }

    // 4. En passant target square
    // 4. مربع الأخذ بالمرور المستهدف
    final enPassantFen = parts[3];
    Cell? enPassantTarget;
    if (enPassantFen != '-') {
      final colChar = enPassantFen.substring(0, 1);
      final rowNum = int.parse(enPassantFen.substring(1, 2));
      final targetCol = colChar.codeUnitAt(0) - 'a'.codeUnitAt(0);
      final targetRow = 8 - rowNum;
      enPassantTarget = Cell(row: targetRow, col: targetCol);
    }

    // 5. Halfmove clock
    // 5. عداد أنصاف الحركات
    final halfMoveClock = int.parse(parts[4]);

    // 6. Fullmove number
    // 6. رقم الحركة الكاملة
    final fullMoveNumber = int.parse(parts[5]);

    final initialFen = _boardToFen(
      squares,
      currentPlayer,
      kingPositions,
      castlingRights,
      enPassantTarget,
      halfMoveClock,
      fullMoveNumber,
    );

    return Board(
      squares: squares,
      currentPlayer: currentPlayer,
      kingPositions: kingPositions,
      castlingRights: castlingRights,
      enPassantTarget: enPassantTarget,
      halfMoveClock: halfMoveClock,
      fullMoveNumber: fullMoveNumber,
      positionHistory: [initialFen], // Add the initial FEN to history
      // أضف FEN الأولي إلى السجل
    );
  }
  factory Board.fromJson(Map<String, dynamic> json) => _$BoardFromJson(json);
}

extension ZobristHashing on Board {
  static final ZobristHasher _hasher = ZobristHasher();

  int computeZobristHash() {
    return _hasher.computeHash(squares, currentPlayer == PieceColor.white);
  }

  int get zobristKey => computeZobristHash();
}

extension OnBoard on Board {
  /// Creates a deep copy of the board, including all pieces, for simulation purposes.
  /// يُنشئ نسخة عميقة من اللوحة، بما في ذلك جميع القطع، لأغراض المحاكاة.
  Board copyWithDeepPieces() {
    final newSquares =
        squares
            .map(
              (row) =>
                  row
                      .map((piece) => piece == null ? piece : piece.copyWith())
                      .toList(),
            )
            .toList(); // نسخ القطع هنا

    // نسخ الخرائط المتغيرة بشكل عميق لضمان عدم وجود مراجع مشتركة
    final newMoveHistory = List<Move>.from(moveHistory);
    final newKingPositions = Map<PieceColor, Cell>.from(kingPositions);
    final newCastlingRights = castlingRights.map(
      (key, value) => MapEntry(key, Map<CastlingSide, bool>.from(value)),
    );
    final newPositionHistory = List<String>.from([
      toFenString(),
    ]); // نسخ سجل الوضعيات

    return Board(
      squares: newSquares,
      moveHistory: newMoveHistory, // استخدم النسخة العميقة
      kingPositions: newKingPositions, // استخدم النسخة العميقة
      castlingRights: newCastlingRights, // استخدم النسخة العميقة
      currentPlayer: currentPlayer,
      enPassantTarget: enPassantTarget,
      fullMoveNumber: fullMoveNumber,
      halfMoveClock: halfMoveClock,
      positionHistory: newPositionHistory, // استخدم النسخة العميقة
    );
  }

  /// Retrieves the piece at a given cell on the board.
  Piece? getPieceAt(Cell cell) {
    if (cell.isValid()) {
      return squares[cell.row][cell.col];
    }
    return null;
  }

  void setPiece(Cell cell, Piece? piece) {
    if (cell.isValid()) {
      squares[cell.row][cell.col] = piece;
    }
  }

  /// يُرجع مثيل Board جديدًا مع وضع قطعة (أو إزالتها إذا كانت القطعة null)
  /// في الخلية المحددة. هذا تحديث غير قابل للتغيير.
  Board placePiece(Cell cell, Piece? piece) {
    final newSquares = squares.map((row) => List<Piece?>.from(row)).toList();
    newSquares[cell.row][cell.col] = piece;
    return copyWith(squares: newSquares);
  }

  /// يتحقق مما إذا كان الملك للّون المحدد في حالة كش (Check).
  bool isKingInCheck(PieceColor kingColor) {
    final kingPosition = kingPositions[kingColor];
    if (kingPosition == null) return false; // لا ينبغي أن يحدث في لعبة عادية

    // تحقق مما إذا كانت أي قطعة للخصم تهدد مربع الملك
    final opponentColor =
        kingColor == PieceColor.white ? PieceColor.black : PieceColor.white;
    for (int r = 0; r < 8; r++) {
      for (int c = 0; c < 8; c++) {
        final currentCell = Cell(row: r, col: c);
        final piece = getPieceAt(currentCell);
        if (piece != null && piece.color == opponentColor) {
          // نحتاج إلى الحصول على الحركات الأولية للقطعة المهاجمة
          // لا نستخدم getLegalMoves هنا لأننا نريد جميع الهجمات، حتى لو كانت تضع ملك المهاجم في كش
          // (مثل دبوس على قطعة الخصم)
          final attackingMoves = piece.getRawMoves(this, currentCell);
          for (var move in attackingMoves) {
            if (move.end == kingPosition) {
              return true; // الملك في كش
            }
          }
        }
      }
    }
    return false;
  }

  /// يتحقق مما إذا كانت الخلية المحددة مهددة من قبل قطع الخصم.
  /// تُستخدم للتحقق من شرعية التبييت.
  bool isCellUnderAttack(PieceColor playerColor, Cell cell) {
    final opponentColor =
        playerColor == PieceColor.white ? PieceColor.black : PieceColor.white;

    for (int r = 0; r < 8; r++) {
      for (int c = 0; c < 8; c++) {
        final currentCell = Cell(row: r, col: c);
        final piece = getPieceAt(currentCell);
        if (piece != null && piece.color == opponentColor) {
          // الحصول على جميع الحركات الأولية للقطعة (التهديدات)
          final attackingMoves = piece.getRawMoves(this, currentCell);
          for (var move in attackingMoves) {
            if (move.end == cell) {
              return true; // الخلية مهددة
            }
          }
        }
      }
    }
    return false;
  }

  //   moveHistory.add(moveWithMeta);
  // }

  /// يقوم بتحويل حالة اللوحة الحالية إلى تمثيل FEN جزئي
  /// (فقط الجزء الضروري لتحديد التكرار الثلاثي).
  String toFenString() {
    String fen = '';
    for (int r = 0; r < 8; r++) {
      int emptyCount = 0;
      for (int c = 0; c < 8; c++) {
        final piece = squares[r][c];
        if (piece == null) {
          emptyCount++;
        } else {
          if (emptyCount > 0) {
            fen += emptyCount.toString();
            emptyCount = 0;
          }
          String pieceChar;
          switch (piece.type) {
            case PieceType.pawn:
              pieceChar = 'p';
              break;
            case PieceType.rook:
              pieceChar = 'r';
              break;
            case PieceType.knight:
              pieceChar = 'n';
              break;
            case PieceType.bishop:
              pieceChar = 'b';
              break;
            case PieceType.queen:
              pieceChar = 'q';
              break;
            case PieceType.king:
              pieceChar = 'k';
              break;
          }
          fen +=
              piece.color == PieceColor.white
                  ? pieceChar.toUpperCase()
                  : pieceChar;
        }
      }
      if (emptyCount > 0) {
        fen += emptyCount.toString();
      }
      if (r < 7) {
        fen += '/';
      }
    }

    // Current player - اللاعب الحالي
    fen += ' ${currentPlayer == PieceColor.white ? 'w' : 'b'}';

    // Castling rights - حقوق التبييت
    String castlingFen = '';
    if (castlingRights[PieceColor.white]![CastlingSide.kingSide]!) {
      castlingFen += 'K';
    }
    if (castlingRights[PieceColor.white]![CastlingSide.queenSide]!) {
      castlingFen += 'Q';
    }
    if (castlingRights[PieceColor.black]![CastlingSide.kingSide]!) {
      castlingFen += 'k';
    }
    if (castlingRights[PieceColor.black]![CastlingSide.queenSide]!) {
      castlingFen += 'q';
    }
    fen += ' ${castlingFen.isEmpty ? '-' : castlingFen}';

    // En passant target square - مربع الأخذ بالمرور المستهدف
    fen +=
        ' ${enPassantTarget == null ? '-' : String.fromCharCode(97 + enPassantTarget!.col) + (8 - enPassantTarget!.row).toString()}';

    // Halfmove clock - عداد أنصاف الحركات
    fen += ' $halfMoveClock';

    // Fullmove number - رقم الحركة الكاملة
    fen += ' $fullMoveNumber';

    return fen;
  }
}

extension WithBoard on Board {
  bool isGameOver() {
    // Check if the current player has any legal moves
    final legalMoves = getAllLegalMovesForCurrentPlayer();
    if (legalMoves.isEmpty) {
      // If no legal moves, check if the king is in check
      if (isKingInCheck(currentPlayer)) {
        return true; // Checkmate
      } else {
        return true; // Stalemate
      }
    }
    return false; // Game is still ongoing
  }

  int evaluateBoard() {
    int score = 0;
    for (int r = 0; r < 8; r++) {
      for (int c = 0; c < 8; c++) {
        final piece = squares[r][c];
        if (piece != null) {
          score += piece.getValue();
        }
      }
    }
    return score;
  }

  bool isMoveResultingInCheck(Board board, Move move) {
    final simulatedBoard = simulateMove(move, board);
    return simulatedBoard.isKingInCheck(board.currentPlayer);
  }

  Board simulateMove(Move move, [Board? boardParameter]) {
    return SimulateMove.simulateMove(boardParameter ?? this, move);
  }

  List<Move> getAllLegalMovesForCurrentPlayer([Board? boardParameter]) {
    final board = boardParameter ?? this;
    // debugPrint("getAllLegalMovesForCurrentPlayer");

    final List<Move> allLegalMoves = [];
    final currentPlayerColor = board.currentPlayer;

    for (int r = 0; r < 8; r++) {
      for (int c = 0; c < 8; c++) {
        final currentCell = Cell(row: r, col: c);
        final piece = board.getPieceAt(currentCell);
        if (piece != null && piece.color == currentPlayerColor) {
          final legalmoves = getLegalMoves(currentCell, board);
          if (legalmoves.isNotEmpty) {
            allLegalMoves.addAll(legalmoves);
          }
        }
      }
    }
    return allLegalMoves;
  }

  List<Move> getLegalMoves(Cell cell, [Board? boardParameter]) {
    final boardToUse = boardParameter ?? this;
    final piece = boardToUse.getPieceAt(cell);
    if (piece == null || piece.color != boardToUse.currentPlayer) {
      return []; // لا توجد قطعة أو ليست قطعة اللاعب الحالي
    }

    // الحصول على الحركات الأولية للقطعة (بغض النظر عن الكش)
    final rawMoves = piece.getRawMoves(boardToUse, cell);

    // تصفية الحركات لإزالة تلك التي تضع الملك في كش
    final legalMoves =
        rawMoves.where((move) {
          return !isMoveResultingInCheck(boardToUse, move);
        }).toList();

    // إضافة حركات الكاستلينج القانونية (يتم التحقق منها هنا بشكل كامل)
    if (piece.type == PieceType.king) {
      _addCastlingMoves(legalMoves, cell, piece.color, boardToUse);
    }
    // إضافة حركات En Passant القانونية (يتم التحقق منها هنا بشكل كامل)
    if (piece.type == PieceType.pawn) {
      _addEnPassantMoves(legalMoves, cell, piece.color, boardToUse);
    }

    return legalMoves;
  }

  /// دالة مساعدة خاصة لإضافة حركات الكاستلينج بعد التحقق من شرعيتها.
  /// الكاستلينج له قواعد خاصة لا يمكن التحقق منها فقط من خلال getRawMoves.
  void _addCastlingMoves(
    List<Move> moves,
    Cell kingCell,
    PieceColor kingColor, [
    Board? boardParameter,
  ]) {
    final board = boardParameter ?? this;
    if (kingColor != board.currentPlayer) return;
    if (board.isKingInCheck(kingColor)) {
      return; // لا يمكن الكاستلينج إذا كان الملك في كش
    }

    final int kingRow = kingColor == PieceColor.white ? 7 : 0;

    // الكاستلينج لجهة الملك (King-side Castling)
    if (board.castlingRights[kingColor]![CastlingSide.kingSide]!) {
      final Cell rookCell = Cell(row: kingRow, col: 7);
      final Piece? rook = board.getPieceAt(rookCell);

      if (rook is Rook &&
          !rook.hasMoved &&
          board.getPieceAt(Cell(row: kingRow, col: 5)) == null &&
          board.getPieceAt(Cell(row: kingRow, col: 6)) == null) {
        // التحقق من أن المربعات التي يمر بها الملك ليست مهددة
        if (!board.isCellUnderAttack(kingColor, Cell(row: kingRow, col: 5)) &&
            !board.isCellUnderAttack(kingColor, Cell(row: kingRow, col: 6))) {
          moves.add(
            Move(
              start: kingCell,
              end: Cell(row: kingRow, col: 6),
              isCastling: true,
              movedPiece: King(
                color: kingColor,
                type: PieceType.king,
                hasMoved: true,
              ),
              castlingRookFrom: rookCell,
              castlingRookTo: Cell(row: kingRow, col: 5),
            ),
          );
        }
      }
    }

    // الكاستلينج لجهة الملكة (Queen-side Castling)
    if (board.castlingRights[kingColor]![CastlingSide.queenSide]!) {
      final Cell rookCell = Cell(row: kingRow, col: 0);
      final Piece? rook = board.getPieceAt(rookCell);

      if (rook is Rook &&
          !rook.hasMoved &&
          board.getPieceAt(Cell(row: kingRow, col: 3)) == null &&
          board.getPieceAt(Cell(row: kingRow, col: 2)) == null &&
          board.getPieceAt(Cell(row: kingRow, col: 1)) == null) {
        // التحقق من أن المربعات التي يمر بها الملك ليست مهددة
        if (!board.isCellUnderAttack(kingColor, Cell(row: kingRow, col: 3)) &&
            !board.isCellUnderAttack(kingColor, Cell(row: kingRow, col: 2)) &&
            !board.isCellUnderAttack(kingColor, Cell(row: kingRow, col: 1))) {
          moves.add(
            Move(
              start: kingCell,
              end: Cell(row: kingRow, col: 2),
              isCastling: true,
              movedPiece: King(
                color: kingColor,
                type: PieceType.king,
                hasMoved: true,
              ),
              castlingRookFrom: rookCell,
              castlingRookTo: Cell(row: kingRow, col: 3),
            ),
          );
        }
      }
    }
  }

  /// دالة مساعدة خاصة لإضافة حركات الـ En Passant بعد التحقق من شرعيتها.
  void _addEnPassantMoves(
    List<Move> moves,
    Cell pawnCell,
    PieceColor pawnColor, [
    Board? boardParameter,
  ]) {
    final board = boardParameter ?? this;
    if (board.enPassantTarget == null) return;

    final int direction = pawnColor == PieceColor.white ? -1 : 1;
    final int targetRow = pawnCell.row + direction;

    // تحقق من الخلايا المجاورة للبيدق لعملية الـ En Passant
    final List<Cell> adjacentCells = [
      Cell(row: pawnCell.row, col: pawnCell.col - 1),
      Cell(row: pawnCell.row, col: pawnCell.col + 1),
    ];

    for (final adjacentCell in adjacentCells) {
      if (adjacentCell.isValid()) {
        final Piece? adjacentPiece = board.getPieceAt(adjacentCell);
        if (adjacentPiece is Pawn &&
            adjacentPiece.color != pawnColor &&
            board.enPassantTarget ==
                Cell(row: targetRow, col: adjacentCell.col) &&
            board.moveHistory.isNotEmpty) {
          // التحقق مما إذا كانت الحركة الأخيرة هي حركة بيدق مزدوجة للبيدق المستهدف
          final lastMove = board.moveHistory.last;
          if (lastMove.isTwoStepPawnMove && lastMove.end == adjacentCell) {
            moves.add(
              Move(
                start: pawnCell,
                end: board.enPassantTarget!,
                isEnPassant: true,
                isCapture: true, // En Passant هو نوع من أنواع الأسر
                movedPiece: Pawn(
                  color: pawnColor,
                  type: PieceType.pawn,
                  hasMoved: true,
                ),
                capturedPiece: board.getPieceAt(board.enPassantTarget!),
                // enPassantTargetBefore: board.enPassantTarget,
              ),
            );
          }
        }
      }
    }
  }
}

// دالة مساعدة لتحويل اللوحة إلى FEN (لاستخدامها في Board.initial)
String _boardToFen(
  List<List<Piece?>> squares,
  PieceColor currentPlayer,
  Map<PieceColor, Cell> kingPositions,
  Map<PieceColor, Map<CastlingSide, bool>> castlingRights,
  Cell? enPassantTarget,
  int halfMoveClock,
  int fullMoveNumber,
) {
  String fen = '';
  for (int r = 0; r < 8; r++) {
    int emptyCount = 0;
    for (int c = 0; c < 8; c++) {
      final piece = squares[r][c];
      if (piece == null) {
        emptyCount++;
      } else {
        if (emptyCount > 0) {
          fen += emptyCount.toString();
          emptyCount = 0;
        }
        String pieceChar;
        switch (piece.type) {
          case PieceType.pawn:
            pieceChar = 'p';
            break;
          case PieceType.rook:
            pieceChar = 'r';
            break;
          case PieceType.knight:
            pieceChar = 'n';
            break;
          case PieceType.bishop:
            pieceChar = 'b';
            break;
          case PieceType.queen:
            pieceChar = 'q';
            break;
          case PieceType.king:
            pieceChar = 'k';
            break;
        }
        fen +=
            piece.color == PieceColor.white
                ? pieceChar.toUpperCase()
                : pieceChar;
      }
    }
    if (emptyCount > 0) {
      fen += emptyCount.toString();
    }
    if (r < 7) {
      fen += '/';
    }
  }

  fen += ' ${currentPlayer == PieceColor.white ? 'w' : 'b'}';

  String castlingFen = '';
  // Since castlingRights is default for initial board, it will be empty map {}
  // when passed to this helper unless explicitly defined. We need to handle this.
  // For initial board, hardcode the full castling rights
  castlingFen += 'KQkq'; // Assuming all castling rights are initially true
  fen += ' ${castlingFen.isEmpty ? '-' : castlingFen}';

  fen +=
      ' ${enPassantTarget == null ? '-' : String.fromCharCode(97 + enPassantTarget.col) + (8 - enPassantTarget.row).toString()}';
  fen += ' $halfMoveClock';
  fen += ' $fullMoveNumber';

  return fen;
}
