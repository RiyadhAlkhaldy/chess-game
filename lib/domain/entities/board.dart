// lib/domain/entities/board.dart
import 'package:freezed_annotation/freezed_annotation.dart';

import 'cell.dart';
import 'move.dart';
import 'piece.dart';

part 'board.freezed.dart'; // Generated by freezed
part 'board.g.dart';

// const _Board({required final  List<List<Piece?>> squares, final  List<Move> moveHistory = const [], this.currentPlayer = PieceColor.white, required final  Map<PieceColor, Cell> kingPositions, final  Map<PieceColor, Map<CastlingSide, bool>> castlingRights = const { PieceColor.white: { CastlingSide.kingSide : true, CastlingSide.queenSide : true},  PieceColor.black : {CastlingSide.kingSide: true, CastlingSide.queenSide: true}}, this.enPassantTarget, this.halfMoveClock = 0, this.fullMoveNumber = 1}): _squares = squares,_moveHistory = moveHistory,_kingPositions = kingPositions,_castlingRights = castlingRights;

/// Represents the current state of the chessboard.
@freezed
abstract class Board with _$Board {
  const factory Board({
    required List<List<Piece?>>
    squares, // 8x8 grid representing the board cells
    @Default([]) List<Move> moveHistory, // History of moves made in the game
    @Default(PieceColor.white)
    PieceColor currentPlayer, // Current player to move
    required Map<PieceColor, Cell>
    kingPositions, // Tracks the current position of each king
    @Default({
      PieceColor.white: {
        CastlingSide.kingSide: true,
        CastlingSide.queenSide: true,
      },
      PieceColor.black: {
        CastlingSide.kingSide: true,
        CastlingSide.queenSide: true,
      },
    })
    Map<PieceColor, Map<CastlingSide, bool>>
    castlingRights, // Tracks castling rights for each player
    // Map<PieceColor, Map<CastlingSide, bool>>
    // castlingLefts, // Tracks castling rights for each player
    Cell? enPassantTarget, // The cell where an en passant capture is possible
    @Default(0)
    int
    halfMoveClock, // Number of half-moves since the last capture or pawn advance (for fifty-move rule)
    @Default(1)
    int fullMoveNumber, // Number of full moves (increments after Black's move)
  }) = _Board;

  /// Factory constructor to set up the initial state of a chess board.
  factory Board.initial() {
    final List<List<Piece?>> initialSquares = List.generate(
      8,
      (_) => List.filled(8, null),
    );

    // Place pawns
    for (int col = 0; col < 8; col++) {
      initialSquares[1][col] = Pawn(
        color: PieceColor.black,
        type: PieceType.pawn,
      );
      initialSquares[6][col] = Pawn(
        color: PieceColor.white,
        type: PieceType.pawn,
      );
    }

    // Place other pieces for Black
    initialSquares[0][0] = Rook(color: PieceColor.black, type: PieceType.rook);
    initialSquares[0][1] = Knight(
      color: PieceColor.black,
      type: PieceType.knight,
    );
    initialSquares[0][2] = Bishop(
      color: PieceColor.black,
      type: PieceType.bishop,
    );
    initialSquares[0][3] = Queen(
      color: PieceColor.black,
      type: PieceType.queen,
    );
    initialSquares[0][4] = King(color: PieceColor.black, type: PieceType.king);
    initialSquares[0][5] = Bishop(
      color: PieceColor.black,
      type: PieceType.bishop,
    );
    initialSquares[0][6] = Knight(
      color: PieceColor.black,
      type: PieceType.knight,
    );
    initialSquares[0][7] = Rook(color: PieceColor.black, type: PieceType.rook);

    // Place other pieces for White
    initialSquares[7][0] = Rook(color: PieceColor.white, type: PieceType.rook);
    initialSquares[7][1] = Knight(
      color: PieceColor.white,
      type: PieceType.knight,
    );
    initialSquares[7][2] = Bishop(
      color: PieceColor.white,
      type: PieceType.bishop,
    );
    initialSquares[7][3] = Queen(
      color: PieceColor.white,
      type: PieceType.queen,
    );
    initialSquares[7][4] = King(color: PieceColor.white, type: PieceType.king);
    initialSquares[7][5] = Bishop(
      color: PieceColor.white,
      type: PieceType.bishop,
    );
    initialSquares[7][6] = Knight(
      color: PieceColor.white,
      type: PieceType.knight,
    );
    initialSquares[7][7] = Rook(color: PieceColor.white, type: PieceType.rook);

    // Initial king positions
    final Map<PieceColor, Cell> initialKingPositions = {
      PieceColor.white: const Cell(row: 7, col: 4),
      PieceColor.black: const Cell(row: 0, col: 4),
    };

    return Board(
      squares: initialSquares,
      kingPositions: initialKingPositions,
      currentPlayer: PieceColor.white,
    );
  }

  factory Board.fromJson(Map<String, dynamic> json) => _$BoardFromJson(json);
}

extension OnBoard on Board {
  /// Creates a deep copy of the board, including all pieces, for simulation purposes.
  /// يُنشئ نسخة عميقة من اللوحة، بما في ذلك جميع القطع، لأغراض المحاكاة.
  Board copyWithDeepPieces() {
    final newSquares =
        squares
            .map(
              (row) =>
                  row
                      .map((piece) => piece == null ? piece : piece.copyWith())
                      .toList(),
            )
            .toList(); // نسخ القطع هنا

    // نسخ الخرائط المتغيرة بشكل عميق لضمان عدم وجود مراجع مشتركة
    final newMoveHistory = List<Move>.from(moveHistory);
    final newKingPositions = Map<PieceColor, Cell>.from(kingPositions);
    final newCastlingRights = castlingRights.map(
      (key, value) => MapEntry(key, Map<CastlingSide, bool>.from(value)),
    );

    return copyWith(
      squares: newSquares,
      moveHistory: newMoveHistory, // استخدم النسخة العميقة
      kingPositions: newKingPositions, // استخدم النسخة العميقة
      castlingRights: newCastlingRights, // استخدم النسخة العميقة
      currentPlayer: currentPlayer,
      enPassantTarget: enPassantTarget,
      fullMoveNumber: fullMoveNumber,
      halfMoveClock: halfMoveClock,
    );
  }

  /// Retrieves the piece at a given cell on the board.
  Piece? getPieceAt(Cell cell) {
    if (cell.isValid()) {
      return squares[cell.row][cell.col];
    }
    return null;
  }

  /// يُرجع مثيل Board جديدًا مع وضع قطعة (أو إزالتها إذا كانت القطعة null)
  /// في الخلية المحددة. هذا تحديث غير قابل للتغيير.
  Board placePiece(Cell cell, Piece? piece) {
    final newSquares = squares.map((row) => List<Piece?>.from(row)).toList();
    newSquares[cell.row][cell.col] = piece;
    return copyWith(squares: newSquares);
  }

  /// يتحقق مما إذا كان الملك للّون المحدد في حالة كش (Check).
  bool isKingInCheck(PieceColor kingColor) {
    final kingPosition = kingPositions[kingColor];
    if (kingPosition == null) return false; // لا ينبغي أن يحدث في لعبة عادية

    // تحقق مما إذا كانت أي قطعة للخصم تهدد مربع الملك
    final opponentColor =
        kingColor == PieceColor.white ? PieceColor.black : PieceColor.white;
    for (int r = 0; r < 8; r++) {
      for (int c = 0; c < 8; c++) {
        final currentCell = Cell(row: r, col: c);
        final piece = getPieceAt(currentCell);
        if (piece != null && piece.color == opponentColor) {
          // نحتاج إلى الحصول على الحركات الأولية للقطعة المهاجمة
          // لا نستخدم getLegalMoves هنا لأننا نريد جميع الهجمات، حتى لو كانت تضع ملك المهاجم في كش
          // (مثل دبوس على قطعة الخصم)
          final attackingMoves = piece.getRawMoves(this, currentCell);
          for (var move in attackingMoves) {
            if (move.end == kingPosition) {
              return true; // الملك في كش
            }
          }
        }
      }
    }
    return false;
  }

  /// يتحقق مما إذا كانت الخلية المحددة مهددة من قبل قطع الخصم.
  /// تُستخدم للتحقق من شرعية التبييت.
  bool isCellUnderAttack(PieceColor playerColor, Cell cell) {
    final opponentColor =
        playerColor == PieceColor.white ? PieceColor.black : PieceColor.white;

    for (int r = 0; r < 8; r++) {
      for (int c = 0; c < 8; c++) {
        final currentCell = Cell(row: r, col: c);
        final piece = getPieceAt(currentCell);
        if (piece != null && piece.color == opponentColor) {
          // الحصول على جميع الحركات الأولية للقطعة (التهديدات)
          final attackingMoves = piece.getRawMoves(this, currentCell);
          for (var move in attackingMoves) {
            if (move.end == cell) {
              return true; // الخلية مهددة
            }
          }
        }
      }
    }
    return false;
  }
}
