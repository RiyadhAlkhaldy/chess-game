// lib/domain/entities/board.dart
import 'package:freezed_annotation/freezed_annotation.dart';

import 'cell.dart';
import 'move.dart';
import 'piece.dart';

part 'board.freezed.dart'; // Generated by freezed
part 'board.g.dart';

// const _Board({required final  List<List<Piece?>> squares, final  List<Move> moveHistory = const [], this.currentPlayer = PieceColor.white, required final  Map<PieceColor, Cell> kingPositions, final  Map<PieceColor, Map<CastlingSide, bool>> castlingRights = const { PieceColor.white: { CastlingSide.kingSide : true, CastlingSide.queenSide : true},  PieceColor.black : {CastlingSide.kingSide: true, CastlingSide.queenSide: true}}, this.enPassantTarget, this.halfMoveClock = 0, this.fullMoveNumber = 1}): _squares = squares,_moveHistory = moveHistory,_kingPositions = kingPositions,_castlingRights = castlingRights;

/// Represents the current state of the chessboard.
@freezed
abstract class Board with _$Board {
  const factory Board({
    required List<List<Piece?>>
    squares, // 8x8 grid representing the board cells
    @Default([]) List<Move> moveHistory, // History of moves made in the game
    @Default(PieceColor.white)
    PieceColor currentPlayer, // Current player to move
    required Map<PieceColor, Cell>
    kingPositions, // Tracks the current position of each king
    @Default({
      PieceColor.white: {
        CastlingSide.kingSide: true,
        CastlingSide.queenSide: true,
      },
      PieceColor.black: {
        CastlingSide.kingSide: true,
        CastlingSide.queenSide: true,
      },
    })
    Map<PieceColor, Map<CastlingSide, bool>>
    castlingRights, // Tracks castling rights for each player
    // Map<PieceColor, Map<CastlingSide, bool>>
    // castlingLefts, // Tracks castling rights for each player
    Cell? enPassantTarget, // The cell where an en passant capture is possible
    @Default(0)
    int
    halfMoveClock, // Number of half-moves since the last capture or pawn advance (for fifty-move rule)
    @Default(1)
    int fullMoveNumber, // Number of full moves (increments after Black's move)
  }) = _Board;

  /// Factory constructor to set up the initial state of a chess board.
  /// with the white player starting.
  factory Board.initialAsWhitePlayer() {
    final List<List<Piece?>> initialSquares = List.generate(
      8,
      (_) => List.filled(8, null),
    );

    // Place pawns
    for (int col = 0; col < 8; col++) {
      initialSquares[1][col] = Pawn(
        color: PieceColor.black,
        type: PieceType.pawn,
      );
      initialSquares[6][col] = Pawn(
        color: PieceColor.white,
        type: PieceType.pawn,
      );
    }

    // Place other pieces for Black
    initialSquares[0][0] = Rook(color: PieceColor.black, type: PieceType.rook);
    initialSquares[0][1] = Knight(
      color: PieceColor.black,
      type: PieceType.knight,
    );
    initialSquares[0][2] = Bishop(
      color: PieceColor.black,
      type: PieceType.bishop,
    );
    initialSquares[0][3] = Queen(
      color: PieceColor.black,
      type: PieceType.queen,
    );
    initialSquares[0][4] = King(color: PieceColor.black, type: PieceType.king);
    initialSquares[0][5] = Bishop(
      color: PieceColor.black,
      type: PieceType.bishop,
    );
    initialSquares[0][6] = Knight(
      color: PieceColor.black,
      type: PieceType.knight,
    );
    initialSquares[0][7] = Rook(color: PieceColor.black, type: PieceType.rook);

    // Place other pieces for White
    initialSquares[7][0] = Rook(color: PieceColor.white, type: PieceType.rook);
    initialSquares[7][1] = Knight(
      color: PieceColor.white,
      type: PieceType.knight,
    );
    initialSquares[7][2] = Bishop(
      color: PieceColor.white,
      type: PieceType.bishop,
    );
    initialSquares[7][3] = Queen(
      color: PieceColor.white,
      type: PieceType.queen,
    );
    initialSquares[7][4] = King(color: PieceColor.white, type: PieceType.king);
    initialSquares[7][5] = Bishop(
      color: PieceColor.white,
      type: PieceType.bishop,
    );
    initialSquares[7][6] = Knight(
      color: PieceColor.white,
      type: PieceType.knight,
    );
    initialSquares[7][7] = Rook(color: PieceColor.white, type: PieceType.rook);

    // Initial king positions
    final Map<PieceColor, Cell> initialKingPositions = {
      PieceColor.white: const Cell(row: 7, col: 4),
      PieceColor.black: const Cell(row: 0, col: 4),
    };

    return Board(
      squares: initialSquares,
      kingPositions: initialKingPositions,
      currentPlayer: PieceColor.white,
    );
  }

  factory Board.fromJson(Map<String, dynamic> json) => _$BoardFromJson(json);
}

extension OnBoard on Board {
  /// Creates a deep copy of the board, including all pieces, for simulation purposes.
  Board copyWithDeepPieces() {
    final newSquares =
        squares.map((row) => row.map((piece) => piece).toList()).toList();
    // Also copy mutable maps/lists if they are directly mutable within the Board
    // final newMoveHistory = List<Move>.from(moveHistory);
    // final newKingPositions = Map<PieceColor, Cell>.from(kingPositions);
    // final newCastlingRights = castlingRights.map(
    //   (key, value) => MapEntry(key, Map<CastlingSide, bool>.from(value)),
    // );

    return copyWith(
      squares: newSquares,
      moveHistory: moveHistory,
      kingPositions: kingPositions,
      castlingRights: castlingRights,
      //! new added for test
      currentPlayer: currentPlayer,
      enPassantTarget: enPassantTarget,
      fullMoveNumber: fullMoveNumber,
      halfMoveClock: halfMoveClock,
    );
  }

  /// Retrieves the piece at a given cell on the board.
  Piece? getPieceAt(Cell cell) {
    if (cell.isValid()) {
      return squares[cell.row][cell.col];
    }
    return null;
  }

  /// Returns a new Board instance with a piece placed (or removed if piece is null)
  /// at the specified cell. This is an immutable update.
  Board placePiece(Cell cell, Piece? piece) {
    final newSquares = squares.map((row) => List<Piece?>.from(row)).toList();
    newSquares[cell.row][cell.col] = piece;
    return copyWith(squares: newSquares);
  }
}
