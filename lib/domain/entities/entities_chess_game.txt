//  lib/domain/entities/piece.dart
import 'package:freezed_annotation/freezed_annotation.dart';

import 'board.dart'; // For board context
import 'cell.dart'; // For cell context
import 'move.dart';

part 'piece.freezed.dart'; // Generated by freezed
part 'piece.g.dart'; // Generated by json_serializable for serialization

/// Enum representing the type of a chess piece.
enum PieceType { king, queen, rook, bishop, knight, pawn }

/// Enum representing the color of a chess piece.
enum PieceColor { white, random, black }

/// Enum representing the side for castling.
enum CastlingSide { kingSide, queenSide }

/// Abstract base class for all chess pieces.
// abstract class Piece with _$Piece {
@freezed
abstract class Piece with _$Piece {
  const Piece._(); // Private constructor for factory
  // final PieceColor color;
  // final PieceType type;
  // final bool hasMoved;
  // const Piece({required this.color, required this.type, this.hasMoved = false});
  factory Piece({
    required PieceColor color, // Color of the piece (white or black)
    required PieceType type, // Type of the piece (king, queen, etc.)
    @Default(false)
    bool
    hasMoved, // Indicates if the piece has moved from its initial position (for castling/pawn)
  }) = _Piece;

  /// Factory constructor to create a Piece from a JSON map.
  factory Piece.fromJson(Map<String, dynamic> json) => _$PieceFromJson(json);

  /// Static factory to create a specific piece instance based on its type and color.
  factory Piece.create({
    required PieceColor color,
    required PieceType type,
    bool hasMoved = true, // Default to true for hasMoved
  }) {
    switch (type) {
      case PieceType.pawn:
        return Pawn(color: color, hasMoved: hasMoved, type: type);
      case PieceType.rook:
        return Rook(color: color, hasMoved: hasMoved, type: type);
      case PieceType.knight:
        return Knight(color: color, hasMoved: hasMoved, type: type);
      case PieceType.bishop:
        return Bishop(color: color, hasMoved: hasMoved, type: type);
      case PieceType.queen:
        return Queen(color: color, hasMoved: hasMoved, type: type);
      case PieceType.king:
        return King(color: color, hasMoved: hasMoved, type: type);
    }
  }

  // /// Converts the Piece object to a JSON map.
  // @override
  // Map<String, dynamic> toJson() => {
  //   'color': color.name,
  //   'type': type.name,
  //   'hasMoved': hasMoved,
  // };
}

extension ONPiece on Piece {
  /// Creates a deep copy of the piece. Used for board simulation.
  Piece copy() => Piece(color: color, type: type);

  /// Abstract method to get all possible raw moves for the piece, without considering
  /// whether the move puts the king in check.
  List<Move> getRawMoves(Board board, Cell currentCell) {
    // debugPrint("in Piece getRawMoves type $type color $color");
    switch (type) {
      case PieceType.pawn:
        return (this as Pawn).getRawMoves(board, currentCell);
      case PieceType.rook:
        return (this as Rook).getRawMoves(board, currentCell);
      case PieceType.knight:
        return (this as Knight).getRawMoves(board, currentCell);
      case PieceType.bishop:
        return (this as Bishop).getRawMoves(board, currentCell);
      case PieceType.queen:
        return (this as Queen).getRawMoves(board, currentCell);
      case PieceType.king:
        return (this as King).getRawMoves(board, currentCell);
    }
  }
}

/// Helper function to generate linear moves (Rook, Bishop, Queen).
/// [directions] is a list of [dx, dy] pairs indicating movement vectors.
List<Move> getLinearMoves(
  Board board,
  Cell currentCell,
  PieceColor pieceColor,
  List<List<int>> directions,
) {
  final moves = <Move>[];
  for (var direction in directions) {
    int dx = direction[0];
    int dy = direction[1];
    Cell nextCell = Cell(row: currentCell.row + dx, col: currentCell.col + dy);

    while (nextCell.isValid()) {
      final targetPiece = board.getPieceAt(nextCell);
      if (targetPiece == null) {
        // Empty square, can move
        moves.add(Move(start: currentCell, end: nextCell));
      } else {
        // Square is occupied
        if (targetPiece.color != pieceColor) {
          // Can capture opponent's piece
          moves.add(Move(start: currentCell, end: nextCell, isCapture: true));
        }
        // Blocked by any piece (own or opponent's)
        break;
      }
      // Move to the next cell in the same direction
      nextCell = Cell(row: nextCell.row + dx, col: nextCell.col + dy);
    }
  }
  return moves;
}

/// Represents a King piece.
@freezed
abstract class King with _$King implements Piece {
  const King._(); // Private constructor

  const factory King({
    required PieceColor color,
    required PieceType type, // Type of the piece (king, queen, etc.)
    @Default(false) bool hasMoved,
  }) = _King;

  factory King.fromJson(Map<String, dynamic> json) => _$KingFromJson(json);

  @override
  PieceType get type => PieceType.king;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    final moves = <Move>[];
    final offsets = [
      [-1, -1],
      [-1, 0],
      [-1, 1],
      [0, -1],
      [0, 1],
      [1, -1],
      [1, 0],
      [1, 1],
    ]; // All 8 adjacent squares

    for (var offset in offsets) {
      final nextCell = Cell(
        row: currentCell.row + offset[0],
        col: currentCell.col + offset[1],
      );
      if (nextCell.isValid()) {
        final targetPiece = board.getPieceAt(nextCell);
        if (targetPiece == null || targetPiece.color != color) {
          // If the target cell is empty or occupied by an opponent's piece
          // Add the move to the list
          moves.add(
            Move(
              start: currentCell,
              end: nextCell,
              isCapture: targetPiece != null,
            ),
          );
        }
      }
    }

    // Castling: Raw moves are generated here. Legality (e.g., passing through check)
    // is checked in GameRepositoryImpl._addCastlingMoves.
    if (!hasMoved) {
      final kingRow = color == PieceColor.white ? 7 : 0;
      // King-side castling
      // Check if the king-side rook has not moved and the squares between the king and rook are empty
      if (board.castlingRights[color]![CastlingSide.kingSide]! &&
          board.getPieceAt(Cell(row: kingRow, col: 5)) == null &&
          board.getPieceAt(Cell(row: kingRow, col: 6)) == null) {
        if (board.isCellUnderAttack(color, Cell(row: kingRow, col: 5)) ==
                false &&
            board.isCellUnderAttack(color, Cell(row: kingRow, col: 6)) ==
                false) {
        moves.add(
          Move(
            start: currentCell,
            end: Cell(row: kingRow, col: 6),
            isCastling: true,
          ),
        );
        }
      }
      // Queen-side castling
      // Check if the queen-side rook has not moved and the squares between the king and rook are empty
      if (board.castlingRights[color]![CastlingSide.queenSide]! &&
          board.getPieceAt(Cell(row: kingRow, col: 3)) == null &&
          board.getPieceAt(Cell(row: kingRow, col: 2)) == null &&
          board.getPieceAt(Cell(row: kingRow, col: 1)) == null) {
        if (board.isCellUnderAttack(color, Cell(row: kingRow, col: 3)) ==
                false &&
            board.isCellUnderAttack(color, Cell(row: kingRow, col: 2)) ==
                false) {
        moves.add(
          Move(
            start: currentCell,
            end: Cell(row: kingRow, col: 2),
            isCastling: true,
          ),
        );
        }
      }
    }
    return moves;
  }

  King copy() => King(color: color, hasMoved: hasMoved, type: type);
}

/// queen
@freezed
abstract class Queen with _$Queen implements Piece {
  const Queen._(); // Private constructor

  const factory Queen({
    required PieceColor color,
    required PieceType type, // Type of the piece (king, queen, etc.)
    @Default(false) bool hasMoved,
  }) = _Queen;

  factory Queen.fromJson(Map<String, dynamic> json) => _$QueenFromJson(json);

  @override
  PieceType get type => PieceType.queen;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    // Queen moves like a Rook + Bishop
    final directions = [
      [-1, 0], [1, 0], [0, -1], [0, 1], // Horizontal & Vertical
      [-1, -1], [-1, 1], [1, -1], [1, 1], // Diagonal
    ];
    return getLinearMoves(board, currentCell, color, directions);
  }

  Queen copy() => Queen(color: color, hasMoved: hasMoved, type: type);
}

// rook

/// Represents a Rook piece.
@freezed
abstract class Rook with _$Rook implements Piece {
  const Rook._(); // Private constructor

  const factory Rook({
    required PieceColor color,
    required PieceType type,
    @Default(false) bool hasMoved,
  }) = _Rook;

  factory Rook.fromJson(Map<String, dynamic> json) => _$RookFromJson(json);

  @override
  PieceType get type => PieceType.rook;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    final directions = [
      [-1, 0], // Up
      [1, 0], // Down
      [0, -1], // Left
      [0, 1], // Right
    ];
    return getLinearMoves(board, currentCell, color, directions);
  }

  Rook copy() => Rook(color: color, hasMoved: hasMoved, type: type);
}

/// Represents a Bishop piece.
@freezed
abstract class Bishop with _$Bishop implements Piece {
  const Bishop._(); // Private constructor

  const factory Bishop({
    required PieceColor color,
    required PieceType type,
    @Default(false) bool hasMoved,
  }) = _Bishop;

  factory Bishop.fromJson(Map<String, dynamic> json) => _$BishopFromJson(json);

  @override
  PieceType get type => PieceType.bishop;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    final directions = [
      [-1, -1],
      [-1, 1],
      [1, -1],
      [1, 1],
    ]; // All 4 diagonal directions
    return getLinearMoves(board, currentCell, color, directions);
  }

  Bishop copy() => Bishop(color: color, hasMoved: hasMoved, type: type);
}

/// Represents a Knight piece.
@freezed
abstract class Knight with _$Knight implements Piece {
  const Knight._(); // Private constructor

  const factory Knight({
    required PieceColor color,
    required PieceType type,
    @Default(false) bool hasMoved,
  }) = _Knight;

  factory Knight.fromJson(Map<String, dynamic> json) => _$KnightFromJson(json);

  @override
  PieceType get type => PieceType.knight;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    final moves = <Move>[];
    final offsets = [
      [1, 2],
      [1, -2],
      [-1, 2],
      [-1, -2],
      [2, 1],
      [2, -1],
      [-2, 1],
      [-2, -1],
    ]; // All 8 L-shaped moves

    for (var offset in offsets) {
      final nextCell = Cell(
        row: currentCell.row + offset[0],
        col: currentCell.col + offset[1],
      );
      if (nextCell.isValid()) {
        final targetPiece = board.getPieceAt(nextCell);
        if (targetPiece == null || targetPiece.color != color) {
          moves.add(
            Move(
              start: currentCell,
              end: nextCell,
              isCapture: targetPiece != null,
            ),
          );
        }
      }
    }
    return moves;
  }

  Knight copy() => Knight(color: color, hasMoved: hasMoved, type: type);
}

/// Represents a Pawn piece.
//
//
@freezed
abstract class Pawn with _$Pawn implements Piece {
  const Pawn._(); // Private constructor

  const factory Pawn({
    required PieceColor color,
    required PieceType type,
    @Default(false) bool hasMoved,
  }) = _Pawn;

  factory Pawn.fromJson(Map<String, dynamic> json) => _$PawnFromJson(json);

  @override
  PieceType get type => PieceType.pawn;

  List<Move> getRawMoves(Board board, Cell currentCell) {
    final moves = <Move>[];
    final direction =
        color == PieceColor.white
            ? -1
            : 1; // -1 for white (up), 1 for black (down)

    // 1. Move forward one square
    final oneStepCell = Cell(
      row: currentCell.row + direction,
      col: currentCell.col,
    );
    if (oneStepCell.isValid() && board.getPieceAt(oneStepCell) == null) {
      // check if promotion is possible
      if (color == PieceColor.white && oneStepCell.row == 0) {
        // White pawn promotion
        moves.add(
          Move(start: currentCell, end: oneStepCell, isPromotion: true),
        );
      } else if (color == PieceColor.black && oneStepCell.row == 7) {
        // Black pawn promotion
        moves.add(
          Move(start: currentCell, end: oneStepCell, isPromotion: true),
        );
      } else {
        // Normal pawn move
        moves.add(Move(start: currentCell, end: oneStepCell));
      }
    }

    // 2. Move forward two squares (initial move)
    final twoStepCell = Cell(
      row: currentCell.row + 2 * direction,
      col: currentCell.col,
    );
    if (!hasMoved &&
        oneStepCell.isValid() &&
        board.getPieceAt(oneStepCell) == null &&
        twoStepCell.isValid() &&
        board.getPieceAt(twoStepCell) == null) {
      moves.add(
        Move(start: currentCell, end: twoStepCell, isTwoStepPawnMove: true),
      );
    }

    // 3. Captures (diagonal)
    final captureLeftCell = Cell(
      row: currentCell.row + direction,
      col: currentCell.col - 1,
    );
    final captureRightCell = Cell(
      row: currentCell.row + direction,
      col: currentCell.col + 1,
    );

    // Check left diagonal capture
    if (captureLeftCell.isValid()) {
      final targetPiece = board.getPieceAt(captureLeftCell);
      if (targetPiece != null && targetPiece.color != color) {
        moves.add(
          Move(start: currentCell, end: captureLeftCell, isCapture: true),
        );
      }
    }

    // Check right diagonal capture
    if (captureRightCell.isValid()) {
      final targetPiece = board.getPieceAt(captureRightCell);
      if (targetPiece != null && targetPiece.color != color) {
        moves.add(
          Move(start: currentCell, end: captureRightCell, isCapture: true),
        );
      }
    }

    // 4. En Passant (requires checking the board's state from the previous move)
    // This will be fully validated in GameRepositoryImpl
    if (board.enPassantTarget != null &&
        (board.enPassantTarget == captureLeftCell ||
            board.enPassantTarget == captureRightCell)) {
      moves.add(
        Move(
          start: currentCell,
          end: board.enPassantTarget!,
          isEnPassant: true,
        ),
      );
    }

    // 5. Promotion (not handled here, should be done in GameRepositoryImpl)
    // Promotion logic is typically handled in the game logic, not in the piece itself.
    // For example, if a pawn reaches the last row, it can be promoted to a queen, rook, bishop, or knight.

    return moves;
  }

  Pawn copy() => Pawn(color: color, hasMoved: hasMoved, type: type);
}

// lib/domain/entities/game_result.dart
import 'package:freezed_annotation/freezed_annotation.dart';

import 'piece.dart'; // For PieceColor

part 'game_result.freezed.dart'; // Generated by freezed

/// Enum representing the possible outcomes of a chess game.
/// تمثيل النتائج المحتملة للعبة الشطرنج
/// Game Outecome = نتيجة اللعبة
/// draw = تعادل , stalemate = طريق مسجود , playing , chechmate
enum GameOutcome { checkmate, stalemate, draw, playing }

/// Enum representing the reasons for a draw
/// Enum يمثل أسباب التعادل.
/// insufficientMaterial = مادة غير كافية, fiftyMoveRule =قاعدة الخمسين حركة,
///  threefoldRepetition = التكرار الثلاثي, agreement = اتفاق
enum DrawReason { insufficientMaterial, fiftyMoveRule, threefoldRepetition, agreement }

/// Represents the current result or state of a chess game.
/// يمثل النتيجة الحالية أو حالة الشطرنج
@freezed
abstract class GameResult with _$GameResult {
  const factory GameResult({
    required GameOutcome outcome, // The outcome of the game
    PieceColor? winner,           // The color of the winning player (if checkmate)
    DrawReason? drawReason,       // The reason for a draw (if draw)
  }) = _GameResult;

  /// Factory constructor for a game that is currently playing.
  factory GameResult.playing() => const GameResult(outcome: GameOutcome.playing);

  /// Factory constructor for a checkmate outcome.
  factory GameResult.checkmate(PieceColor winner) => GameResult(outcome: GameOutcome.checkmate, winner: winner);

  /// Factory constructor for a stalemate outcome.
  factory GameResult.stalemate() => const GameResult(outcome: GameOutcome.stalemate);

  /// Factory constructor for a draw outcome with a specific reason.
  factory GameResult.draw(DrawReason reason) => GameResult(outcome: GameOutcome.draw, drawReason: reason);
}


// lib/domain/entities/move.dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'cell.dart';
import 'piece.dart'; // Needed for PieceType in promotion

part 'move.freezed.dart'; // Generated by freezed
part 'move.g.dart'; // Generated by freezed

/// Represents a single move in the chess game.
@freezed
abstract class Move with _$Move {
  const factory Move({
    required Cell start, // Starting cell of the piece
    required Cell end, // Ending cell of the piece
    @Default(false) bool isCapture, // True if this move is a capture
    @Default(false) bool isCastling, // True if this move is castling
    @Default(false)
    bool isEnPassant, // True if this move is an en passant capture
    @Default(false) bool isPromotion, // True if this move is a pawn promotion
    PieceType?
    promotedPieceType, // The type of piece the pawn promotes to (if isPromotion is true)
    @Default(false)
    bool
    isTwoStepPawnMove, // True if a pawn moved two squares (for en passant tracking)
  }) = _Move;

  factory Move.fromJson(Map<String, dynamic> json) => _$MoveFromJson(json);
}


// lib/domain/entities/cell.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'cell.freezed.dart'; // Generated by freezed
part 'cell.g.dart';

/// Represents a single cell on the chessboard with its row and column coordinates.
@freezed
abstract class Cell with _$Cell {
  const factory Cell({
    required int row, // Row index (0-7)
    required int col, // Column index (0-7)
  }) = _Cell;

  /// Checks if the cell coordinates are within the valid 8x8 board boundaries.
  // bool isValid() => row >= 0 && row < 8 && col >= 0 && col < 8;

  factory Cell.fromJson(Map<String, dynamic> json) => _$CellFromJson(json);
}

extension CellValidate on Cell {
  bool isValid() => row >= 0 && row < 8 && col >= 0 && col < 8;
}

extension CellColor on Cell {
  /// يتحقق مما إذا كانت الخلية ذات لون فاتح (أبيض) أو داكن (أسود).
  /// تُستخدم لتحديد لون مربع الأسقف.
  bool isLightSquare() => (row + col) % 2 == 0;
  bool isDarkSquare() => (row + col) % 2 != 0;
}

import 'package:chess_gemini_2/domain/repositories/zobrist_hashing.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../data/chess_logic.dart';
import '../repositories/simulate_move.dart';
import 'cell.dart';
import 'move.dart';
import 'piece.dart';

part 'board.freezed.dart'; // Generated by freezed
part 'board.g.dart';

/// Represents the current state of the chessboard.
@freezed
abstract class Board with _$Board {
  const factory Board({
    required List<List<Piece?>>
    squares, // 8x8 grid representing the board cells
    @Default([]) List<Move> moveHistory, // History of moves made in the game
    @Default([]) List<Move> redoStack, // History of moves that can be redone
    @Default(PieceColor.white)
    PieceColor currentPlayer, // Current player to move
    required Map<PieceColor, Cell>
    kingPositions, // Tracks the current position of each king
    @Default({
      PieceColor.white: {
        CastlingSide.kingSide: true,
        CastlingSide.queenSide: true,
      },
      PieceColor.black: {
        CastlingSide.kingSide: true,
        CastlingSide.queenSide: true,
      },
    })
    Map<PieceColor, Map<CastlingSide, bool>>
    castlingRights, // Tracks castling rights for each player
    // Map<PieceColor, Map<CastlingSide, bool>>
    // castlingLefts, // Tracks castling rights for each player
    Cell? enPassantTarget, // The cell where an en passant capture is possible
    @Default(0)
    int
    halfMoveClock, // Number of half-moves since the last capture or pawn advance (for fifty-move rule)
    @Default(1)
    int fullMoveNumber, // Number of full moves (increments after Black's move)
    // إضافة لسجل وضعيات اللوحة للتحقق من التكرار الثلاثي
    // A list of FEN strings or a similar unique board state representation
    @Default([]) List<String> positionHistory,
    required int zobristKey,
  }) = _Board;
  // static final ZobristHasher hasher = ZobristHasher();

  /// Factory constructor to set up the initial state of a chess board.
  factory Board.initial() {
    if (!ZobristHashing.zobristKeysInitialized) {
      ZobristHashing.initializeZobristKeys();
      ZobristHashing.zobristKeysInitialized = true;
    }
    final List<List<Piece?>> initialSquares = List.generate(
      8,
      (_) => List.filled(8, null),
    );

    // Place pawns
    for (int col = 0; col < 8; col++) {
      initialSquares[1][col] = Pawn(
        color: PieceColor.black,
        type: PieceType.pawn,
      );
      initialSquares[6][col] = Pawn(
        color: PieceColor.white,
        type: PieceType.pawn,
      );
    }

    // Place other pieces for Black
    initialSquares[0][0] = Rook(color: PieceColor.black, type: PieceType.rook);
    initialSquares[0][1] = Knight(
      color: PieceColor.black,
      type: PieceType.knight,
    );
    initialSquares[0][2] = Bishop(
      color: PieceColor.black,
      type: PieceType.bishop,
    );
    initialSquares[0][3] = Queen(
      color: PieceColor.black,
      type: PieceType.queen,
    );
    initialSquares[0][4] = King(color: PieceColor.black, type: PieceType.king);
    initialSquares[0][5] = Bishop(
      color: PieceColor.black,
      type: PieceType.bishop,
    );
    initialSquares[0][6] = Knight(
      color: PieceColor.black,
      type: PieceType.knight,
    );
    initialSquares[0][7] = Rook(color: PieceColor.black, type: PieceType.rook);

    // Place other pieces for White
    initialSquares[7][0] = Rook(color: PieceColor.white, type: PieceType.rook);
    initialSquares[7][1] = Knight(
      color: PieceColor.white,
      type: PieceType.knight,
    );
    initialSquares[7][2] = Bishop(
      color: PieceColor.white,
      type: PieceType.bishop,
    );
    initialSquares[7][3] = Queen(
      color: PieceColor.white,
      type: PieceType.queen,
    );
    initialSquares[7][4] = King(color: PieceColor.white, type: PieceType.king);
    initialSquares[7][5] = Bishop(
      color: PieceColor.white,
      type: PieceType.bishop,
    );
    initialSquares[7][6] = Knight(
      color: PieceColor.white,
      type: PieceType.knight,
    );
    initialSquares[7][7] = Rook(color: PieceColor.white, type: PieceType.rook);

    // Initial king positions
    final Map<PieceColor, Cell> initialKingPositions = {
      PieceColor.white: const Cell(row: 7, col: 4),
      PieceColor.black: const Cell(row: 0, col: 4),
    };
    // Initial FEN for the starting position - FEN الأولي للوضعية الافتتاحية
    final initialFen = _boardToFen(
      initialSquares,
      PieceColor.white,
      initialKingPositions,
      const {},
      null,
      0,
      1,
    );

    final Board initialBoard = Board(
      squares: initialSquares,
      kingPositions: initialKingPositions,
      currentPlayer: PieceColor.white,
      positionHistory: [initialFen], // Add initial position to history
      zobristKey: 0, // Zobrist key for the board state
    );
    final int initialKey = ZobristHashing.calculateZobristKey(initialBoard);
    return initialBoard.copyWith(zobristKey: initialKey);
  }

  /// Builds a Board object from a FEN (Forsyth-Edwards Notation) string.
  /// يبني كائن Board من سلسلة FEN (تدوين فورسيث-إدواردز).
  factory Board.fenToBoard(String fen) {
    if (!ZobristHashing.zobristKeysInitialized) {
      ZobristHashing.initializeZobristKeys();
      ZobristHashing.zobristKeysInitialized = true;
    }
    final parts = fen.split(' ');
    if (parts.length != 6) {
      throw ArgumentError('Invalid FEN string: "$fen". Must have 6 parts.');
    }

    // 1. Piece placement data (board state)
    // 1. بيانات وضع القطع (حالة اللوحة)
    final piecePlacement = parts[0];
    final List<List<Piece?>> squares = List.generate(
      8,
      (_) => List.filled(8, null),
    );
    final Map<PieceColor, Cell> kingPositions = {};

    int row = 0;
    int col = 0;
    for (int i = 0; i < piecePlacement.length; i++) {
      final char = piecePlacement[i];
      if (char == '/') {
        row++;
        col = 0;
      } else if (int.tryParse(char) != null) {
        col += int.parse(char);
      } else {
        final PieceColor color =
            char.toUpperCase() == char ? PieceColor.white : PieceColor.black;
        PieceType type;
        switch (char.toLowerCase()) {
          case 'p':
            type = PieceType.pawn;
            break;
          case 'r':
            type = PieceType.rook;
            break;
          case 'n':
            type = PieceType.knight;
            break;
          case 'b':
            type = PieceType.bishop;
            break;
          case 'q':
            type = PieceType.queen;
            break;
          case 'k':
            type = PieceType.king;
            // Track king positions
            // تتبع مواقع الملوك
            kingPositions[color] = Cell(row: row, col: col);
            break;
          default:
            throw ArgumentError('Invalid piece character in FEN: $char');
        }
        // Determine if the piece has moved. For FEN, we assume all pieces
        // have "moved" unless they are in their initial pawn/rook/king positions
        // that allow special moves like castling or two-step pawn moves.
        // Since FEN only gives the current state, `hasMoved` is tricky.
        // For castling, we rely on the castling rights string.
        // For pawns, if they are not on their starting rank, they have "moved".
        // تحديد ما إذا كانت القطعة قد تحركت. بالنسبة لـ FEN، نفترض أن جميع القطع
        // "تحركت" ما لم تكن في مواقعها الأولية للبيدق/الرخ/الملك
        // التي تسمح بحركات خاصة مثل التبييت أو حركات البيدق المزدوجة.
        // بما أن FEN يعطي الحالة الحالية فقط، فإن `hasMoved` أمر معقد.
        // بالنسبة للتبييت، نعتمد على سلسلة حقوق التبييت.
        // بالنسبة للبيادق، إذا لم تكن في صف البداية، فقد "تحركت".
        bool hasMoved = true;
        if (type == PieceType.pawn) {
          if ((color == PieceColor.white && row == 6) ||
              (color == PieceColor.black && row == 1)) {
            hasMoved =
                false; // Pawns on starting rank are considered not moved for 2-step
            // البيادق في صف البداية تعتبر غير متحركة لحركة الخطوتين
          }
        } else if (type == PieceType.king) {
          if ((color == PieceColor.white && row == 7 && col == 4) ||
              (color == PieceColor.black && row == 0 && col == 4)) {
            // Has moved status for King will be overwritten by castling rights.
            // ستتم الكتابة فوق حالة "تحرك" للملك بواسطة حقوق التبييت.
            hasMoved = false;
          }
        } else if (type == PieceType.rook) {
          // Has moved status for Rook will be overwritten by castling rights.
          // ستتم الكتابة فوق حالة "تحرك" للرخ بواسطة حقوق التبييت.
          if ((color == PieceColor.white &&
                  ((row == 7 && col == 0) || (row == 7 && col == 7))) ||
              (color == PieceColor.black &&
                  ((row == 0 && col == 0) || (row == 0 && col == 7)))) {
            hasMoved = false;
          }
        }

        squares[row][col] = Piece.create(
          color: color,
          type: type,
          hasMoved: hasMoved,
        );
        col++;
      }
    }

    // 2. Active color
    // 2. اللون النشط
    final currentPlayer = parts[1] == 'w' ? PieceColor.white : PieceColor.black;

    // 3. Castling availability
    // 3. توفر التبييت
    final castlingFen = parts[2];
    final Map<PieceColor, Map<CastlingSide, bool>> castlingRights = {
      PieceColor.white: {
        CastlingSide.kingSide: false,
        CastlingSide.queenSide: false,
      },
      PieceColor.black: {
        CastlingSide.kingSide: false,
        CastlingSide.queenSide: false,
      },
    };
    if (castlingFen != '-') {
      if (castlingFen.contains('K')) {
        castlingRights[PieceColor.white]![CastlingSide.kingSide] = true;
      }
      if (castlingFen.contains('Q')) {
        castlingRights[PieceColor.white]![CastlingSide.queenSide] = true;
      }
      if (castlingFen.contains('k')) {
        castlingRights[PieceColor.black]![CastlingSide.kingSide] = true;
      }
      if (castlingFen.contains('q')) {
        castlingRights[PieceColor.black]![CastlingSide.queenSide] = true;
      }
    }

    // Set hasMoved for kings and rooks based on castling rights
    // If castling right exists for a side, the king and corresponding rook for that side must not have moved.
    // اضبط hasMoved للملوك والرخاخ بناءً على حقوق التبييت
    // إذا كان حق التبييت موجودًا لجانب ما، يجب ألا يكون الملك والرخ المقابل لهذا الجانب قد تحركا.
    if (castlingRights[PieceColor.white]![CastlingSide.kingSide] == true) {
      if (squares[7][4] is King && squares[7][4]!.color == PieceColor.white) {
        squares[7][4] = (squares[7][4] as King).copyWith(hasMoved: false);
      }
      if (squares[7][7] is Rook && squares[7][7]!.color == PieceColor.white) {
        squares[7][7] = (squares[7][7] as Rook).copyWith(hasMoved: false);
      }
    }
    if (castlingRights[PieceColor.white]![CastlingSide.queenSide] == true) {
      if (squares[7][4] is King && squares[7][4]!.color == PieceColor.white) {
        squares[7][4] = (squares[7][4] as King).copyWith(hasMoved: false);
      }
      if (squares[7][0] is Rook && squares[7][0]!.color == PieceColor.white) {
        squares[7][0] = (squares[7][0] as Rook).copyWith(hasMoved: false);
      }
    }
    if (castlingRights[PieceColor.black]![CastlingSide.kingSide] == true) {
      if (squares[0][4] is King && squares[0][4]!.color == PieceColor.black) {
        squares[0][4] = (squares[0][4] as King).copyWith(hasMoved: false);
      }
      if (squares[0][7] is Rook && squares[0][7]!.color == PieceColor.black) {
        squares[0][7] = (squares[0][7] as Rook).copyWith(hasMoved: false);
      }
    }
    if (castlingRights[PieceColor.black]![CastlingSide.queenSide] == true) {
      if (squares[0][4] is King && squares[0][4]!.color == PieceColor.black) {
        squares[0][4] = (squares[0][4] as King).copyWith(hasMoved: false);
      }
      if (squares[0][0] is Rook && squares[0][0]!.color == PieceColor.black) {
        squares[0][0] = (squares[0][0] as Rook).copyWith(hasMoved: false);
      }
    }

    // 4. En passant target square
    // 4. مربع الأخذ بالمرور المستهدف
    final enPassantFen = parts[3];
    Cell? enPassantTarget;
    if (enPassantFen != '-') {
      final colChar = enPassantFen.substring(0, 1);
      final rowNum = int.parse(enPassantFen.substring(1, 2));
      final targetCol = colChar.codeUnitAt(0) - 'a'.codeUnitAt(0);
      final targetRow = 8 - rowNum;
      enPassantTarget = Cell(row: targetRow, col: targetCol);
    }

    // 5. Halfmove clock
    // 5. عداد أنصاف الحركات
    final halfMoveClock = int.parse(parts[4]);

    // 6. Fullmove number
    // 6. رقم الحركة الكاملة
    final fullMoveNumber = int.parse(parts[5]);

    final initialFen = _boardToFen(
      squares,
      currentPlayer,
      kingPositions,
      castlingRights,
      enPassantTarget,
      halfMoveClock,
      fullMoveNumber,
    );

    return Board(
      squares: squares,
      currentPlayer: currentPlayer,
      kingPositions: kingPositions,
      castlingRights: castlingRights,
      enPassantTarget: enPassantTarget,
      halfMoveClock: halfMoveClock,
      fullMoveNumber: fullMoveNumber,
      positionHistory: [initialFen], // Add the initial FEN to history
      zobristKey: 0, // Zobrist key for the board state
    );
  }
  factory Board.fromJson(Map<String, dynamic> json) => _$BoardFromJson(json);
}

extension ZobristHashingBoard on Board {
  int computeZobristHash() {
    return 0;
    // return Board.hasher.computeHash(this, currentPlayer == PieceColor.white);
  }

  int get zobristKey => computeZobristHash();
}

extension OnBoard on Board {
  /// Creates a deep copy of the board, including all pieces, for simulation purposes.
  /// يُنشئ نسخة عميقة من اللوحة، بما في ذلك جميع القطع، لأغراض المحاكاة.
  Board copyWithDeepPieces() {
    final newSquares =
        squares
            .map(
              (row) =>
                  row
                      .map((piece) => piece == null ? piece : piece.copyWith())
                      .toList(),
            )
            .toList(); // نسخ القطع هنا

    // نسخ الخرائط المتغيرة بشكل عميق لضمان عدم وجود مراجع مشتركة
    final newMoveHistory = List<Move>.from(moveHistory);
    final newKingPositions = Map<PieceColor, Cell>.from(kingPositions);
    final newCastlingRights = castlingRights.map(
      (key, value) => MapEntry(key, Map<CastlingSide, bool>.from(value)),
    );
    final newPositionHistory = List<String>.from([
      toFenString(),
    ]); // نسخ سجل الوضعيات

    return Board(
      squares: newSquares,
      moveHistory: newMoveHistory, // استخدم النسخة العميقة
      kingPositions: newKingPositions, // استخدم النسخة العميقة
      castlingRights: newCastlingRights, // استخدم النسخة العميقة
      currentPlayer: currentPlayer,
      enPassantTarget: enPassantTarget,
      fullMoveNumber: fullMoveNumber,
      halfMoveClock: halfMoveClock,
      positionHistory: newPositionHistory, // استخدم النسخة العميقة
      zobristKey: zobristKey, // إعادة حساب المفتاح Zobrist
    );
  }

  /// Retrieves the piece at a given cell on the board.
  Piece? getPieceAt(Cell cell) {
    if (cell.isValid()) {
      return squares[cell.row][cell.col];
    }
    return null;
  }

  void setPiece(Cell cell, Piece? piece) {
    if (cell.isValid()) {
      squares[cell.row][cell.col] = piece;
    }
  }

  /// يُرجع مثيل Board جديدًا مع وضع قطعة (أو إزالتها إذا كانت القطعة null)
  /// في الخلية المحددة. هذا تحديث غير قابل للتغيير.
  Board placePiece(Cell cell, Piece? piece) {
    final newSquares = squares.map((row) => List<Piece?>.from(row)).toList();
    newSquares[cell.row][cell.col] = piece;
    return copyWith(squares: newSquares);
  }

  /// يتحقق مما إذا كان الملك للّون المحدد في حالة كش (Check).
  bool isKingInCheck(PieceColor kingColor) {
    final kingPosition = kingPositions[kingColor];
    if (kingPosition == null) return false; // لا ينبغي أن يحدث في لعبة عادية

    // تحقق مما إذا كانت أي قطعة للخصم تهدد مربع الملك
    final opponentColor =
        kingColor == PieceColor.white ? PieceColor.black : PieceColor.white;
    for (int r = 0; r < 8; r++) {
      for (int c = 0; c < 8; c++) {
        final currentCell = Cell(row: r, col: c);
        final piece = getPieceAt(currentCell);
        if (piece != null && piece.color == opponentColor) {
          // نحتاج إلى الحصول على الحركات الأولية للقطعة المهاجمة
          // لا نستخدم getLegalMoves هنا لأننا نريد جميع الهجمات، حتى لو كانت تضع ملك المهاجم في كش
          // (مثل دبوس على قطعة الخصم)
          final attackingMoves = piece.getRawMoves(this, currentCell);
          for (var move in attackingMoves) {
            if (move.end == kingPosition) {
              return true; // الملك في كش
            }
          }
        }
      }
    }
    return false;
  }

  /// يتحقق مما إذا كانت الخلية المحددة مهددة من قبل قطع الخصم.
  /// تُستخدم للتحقق من شرعية التبييت.
  bool isCellUnderAttack(PieceColor playerColor, Cell cell) {
    final opponentColor =
        playerColor == PieceColor.white ? PieceColor.black : PieceColor.white;

    for (int r = 0; r < 8; r++) {
      for (int c = 0; c < 8; c++) {
        final currentCell = Cell(row: r, col: c);
        final piece = getPieceAt(currentCell);
        if (piece != null && piece.color == opponentColor) {
          // الحصول على جميع الحركات الأولية للقطعة (التهديدات)
          final attackingMoves = piece.getRawMoves(this, currentCell);
          for (var move in attackingMoves) {
            if (move.end == cell) {
              return true; // الخلية مهددة
            }
          }
        }
      }
    }
    return false;
  }

  //   moveHistory.add(moveWithMeta);
  // }

  /// يقوم بتحويل حالة اللوحة الحالية إلى تمثيل FEN جزئي
  /// (فقط الجزء الضروري لتحديد التكرار الثلاثي).
  String toFenString() {
    String fen = '';
    for (int r = 0; r < 8; r++) {
      int emptyCount = 0;
      for (int c = 0; c < 8; c++) {
        final piece = squares[r][c];
        if (piece == null) {
          emptyCount++;
        } else {
          if (emptyCount > 0) {
            fen += emptyCount.toString();
            emptyCount = 0;
          }
          String pieceChar;
          switch (piece.type) {
            case PieceType.pawn:
              pieceChar = 'p';
              break;
            case PieceType.rook:
              pieceChar = 'r';
              break;
            case PieceType.knight:
              pieceChar = 'n';
              break;
            case PieceType.bishop:
              pieceChar = 'b';
              break;
            case PieceType.queen:
              pieceChar = 'q';
              break;
            case PieceType.king:
              pieceChar = 'k';
              break;
          }
          fen +=
              piece.color == PieceColor.white
                  ? pieceChar.toUpperCase()
                  : pieceChar;
        }
      }
      if (emptyCount > 0) {
        fen += emptyCount.toString();
      }
      if (r < 7) {
        fen += '/';
      }
    }

    // Current player - اللاعب الحالي
    fen += ' ${currentPlayer == PieceColor.white ? 'w' : 'b'}';

    // Castling rights - حقوق التبييت
    String castlingFen = '';
    if (castlingRights[PieceColor.white]![CastlingSide.kingSide]!) {
      castlingFen += 'K';
    }
    if (castlingRights[PieceColor.white]![CastlingSide.queenSide]!) {
      castlingFen += 'Q';
    }
    if (castlingRights[PieceColor.black]![CastlingSide.kingSide]!) {
      castlingFen += 'k';
    }
    if (castlingRights[PieceColor.black]![CastlingSide.queenSide]!) {
      castlingFen += 'q';
    }
    fen += ' ${castlingFen.isEmpty ? '-' : castlingFen}';

    // En passant target square - مربع الأخذ بالمرور المستهدف
    fen +=
        ' ${enPassantTarget == null ? '-' : String.fromCharCode(97 + enPassantTarget!.col) + (8 - enPassantTarget!.row).toString()}';

    // Halfmove clock - عداد أنصاف الحركات
    fen += ' $halfMoveClock';

    // Fullmove number - رقم الحركة الكاملة
    fen += ' $fullMoveNumber';

    return fen;
  }
}

extension WithBoard on Board {
  bool isGameOver() {
    // Check if the current player has any legal moves
    final legalMoves = getAllLegalMovesForCurrentPlayer();
    if (legalMoves.isEmpty) {
      // If no legal moves, check if the king is in check
      if (isKingInCheck(currentPlayer)) {
        return true; // Checkmate
      } else {
        return true; // Stalemate
      }
    }
    return false; // Game is still ongoing
  }

  int evaluateBoard() {
    int score = 0;
    for (int r = 0; r < 8; r++) {
      for (int c = 0; c < 8; c++) {
        final piece = squares[r][c];
        if (piece != null) {
          score += piece.getValue();
        }
      }
    }
    return score;
  }

  Board simulateMove(Move move, [Board? boardParameter]) {
    return SimulateMove.simulateMove(boardParameter ?? this, move);
  }

  List<Move> getAllLegalMovesForCurrentPlayer([Board? boardParameter]) =>
      ChessLogic.getAllLegalMovesForCurrentPlayer(boardParameter ?? this);

  List<Move> getLegalMoves(Cell cell, [Board? boardParameter]) =>
      ChessLogic.getLegalMoves(cell, boardParameter ?? this);
}

// دالة مساعدة لتحويل اللوحة إلى FEN (لاستخدامها في Board.initial)
String _boardToFen(
  List<List<Piece?>> squares,
  PieceColor currentPlayer,
  Map<PieceColor, Cell> kingPositions,
  Map<PieceColor, Map<CastlingSide, bool>> castlingRights,
  Cell? enPassantTarget,
  int halfMoveClock,
  int fullMoveNumber,
) {
  String fen = '';
  for (int r = 0; r < 8; r++) {
    int emptyCount = 0;
    for (int c = 0; c < 8; c++) {
      final piece = squares[r][c];
      if (piece == null) {
        emptyCount++;
      } else {
        if (emptyCount > 0) {
          fen += emptyCount.toString();
          emptyCount = 0;
        }
        String pieceChar;
        switch (piece.type) {
          case PieceType.pawn:
            pieceChar = 'p';
            break;
          case PieceType.rook:
            pieceChar = 'r';
            break;
          case PieceType.knight:
            pieceChar = 'n';
            break;
          case PieceType.bishop:
            pieceChar = 'b';
            break;
          case PieceType.queen:
            pieceChar = 'q';
            break;
          case PieceType.king:
            pieceChar = 'k';
            break;
        }
        fen +=
            piece.color == PieceColor.white
                ? pieceChar.toUpperCase()
                : pieceChar;
      }
    }
    if (emptyCount > 0) {
      fen += emptyCount.toString();
    }
    if (r < 7) {
      fen += '/';
    }
  }

  fen += ' ${currentPlayer == PieceColor.white ? 'w' : 'b'}';

  String castlingFen = '';
  // Since castlingRights is default for initial board, it will be empty map {}
  // when passed to this helper unless explicitly defined. We need to handle this.
  // For initial board, hardcode the full castling rights
  castlingFen += 'KQkq'; // Assuming all castling rights are initially true
  fen += ' ${castlingFen.isEmpty ? '-' : castlingFen}';

  fen +=
      ' ${enPassantTarget == null ? '-' : String.fromCharCode(97 + enPassantTarget.col) + (8 - enPassantTarget.row).toString()}';
  fen += ' $halfMoveClock';
  fen += ' $fullMoveNumber';

  return fen;
}
